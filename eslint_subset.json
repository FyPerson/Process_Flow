[
  {
    "filePath": "E:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\CustomNode\\index.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/set-state-in-effect",
        "severity": 2,
        "message": "Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nE:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\CustomNode\\index.tsx:92:5\n  90 |   useEffect(() => {\n  91 |     // åªæœ‰å½“å€¼çœŸæ­£å˜åŒ–æ—¶æ‰æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“\n> 92 |     setEditValue((prev) => {\n     |     ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  93 |       if (prev !== nodeData.name) return nodeData.name;\n  94 |       return prev;\n  95 |     });",
        "line": 92,
        "column": 5,
        "nodeType": null,
        "endLine": 92,
        "endColumn": 17
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "The ref value 'edgeUpdateFrameRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'edgeUpdateFrameRef.current' to a variable inside the effect, and use that variable in the cleanup function.",
        "line": 187,
        "column": 49,
        "nodeType": "Identifier",
        "endLine": 187,
        "endColumn": 56
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { memo, useState, useCallback, useRef, useEffect, CSSProperties } from 'react';\r\nimport {\r\n  Handle,\r\n  Position,\r\n  NodeProps,\r\n  useReactFlow,\r\n  NodeResizer,\r\n  useUpdateNodeInternals,\r\n} from '@xyflow/react';\r\nimport { FlowNodeData } from '../../types/flow';\r\nimport './styles.css';\r\n\r\ninterface CustomNodeProps extends NodeProps {\r\n  style?: CSSProperties;\r\n}\r\n\r\nexport const CustomNode = memo(({ id, data, selected, style }: CustomNodeProps) => {\r\n  const nodeData = data as unknown as FlowNodeData;\r\n  const { setNodes, getNode } = useReactFlow();\r\n  const updateNodeInternals = useUpdateNodeInternals();\r\n\r\n  // ç¼–è¾‘çŠ¶æ€\r\n  const [isEditing, setIsEditing] = useState(false);\r\n  const [editValue, setEditValue] = useState(nodeData.name);\r\n  const [originalValue, setOriginalValue] = useState(nodeData.name); // ä¿å­˜ç¼–è¾‘å‰çš„åŸå§‹å€¼\r\n\r\n  const inputRef = useRef<HTMLTextAreaElement>(null);\r\n  // ç”¨äºèŠ‚æµè¿æ¥çº¿æ›´æ–°çš„ ref (è™½ç„¶ç›®å‰æœªåœ¨å…¶ä»–åœ°æ–¹ä½¿ç”¨ï¼Œä½†ä¿ç•™å…¶å£°æ˜ä»¥é˜²æœªæ¥æ‰©å±•)\r\n  const edgeUpdateFrameRef = useRef<number | null>(null);\r\n\r\n  // ä»èŠ‚ç‚¹å¯¹è±¡ä¸­è·å–å®Œæ•´çš„ styleï¼ˆåŒ…æ‹¬ä» React Flow ä¼ é€’çš„å’ŒèŠ‚ç‚¹æœ¬èº«çš„ï¼‰\r\n  const nodeStyle = style || getNode(id)?.style;\r\n\r\n  // è·å–èƒŒæ™¯è‰²ï¼š\r\n  // å¯¹äºåˆ¤æ–­èŠ‚ç‚¹å’Œæ•°æ®èŠ‚ç‚¹ï¼Œä» data.backgroundColor è¯»å–ï¼ˆä¸ä¿å­˜åœ¨ style ä¸­ï¼Œé¿å…åº”ç”¨åˆ°å¤–å±‚å®¹å™¨ï¼‰\r\n  // å¯¹äºå…¶ä»–èŠ‚ç‚¹ï¼Œä» style ä¸­è¯»å–\r\n  let backgroundColor: string | null = null;\r\n  if (nodeData.type === 'decision' || nodeData.type === 'data') {\r\n    backgroundColor = nodeData.backgroundColor || null;\r\n  } else {\r\n    backgroundColor =\r\n      nodeStyle?.backgroundColor ||\r\n      (typeof nodeStyle?.background === 'string' &&\r\n        !nodeStyle.background.includes('gradient') &&\r\n        !nodeStyle.background.includes('url')\r\n        ? nodeStyle.background\r\n        : null);\r\n  }\r\n\r\n  // è·å–å­—å·ï¼šä» style ä¸­è¯»å– fontSize\r\n  const fontSize = nodeStyle?.fontSize\r\n    ? typeof nodeStyle.fontSize === 'number'\r\n      ? `${nodeStyle.fontSize}px`\r\n      : nodeStyle.fontSize\r\n    : undefined;\r\n\r\n  // è·å–å­—ä½“é¢œè‰²ï¼šä» style ä¸­è¯»å– color\r\n  const fontColor = nodeStyle?.color as string | undefined;\r\n\r\n  // è·å–å­—ä½“æ—ï¼šä» style ä¸­è¯»å– fontFamily\r\n  const fontFamily = nodeStyle?.fontFamily as string | undefined;\r\n\r\n  // è·å–å­—ä½“ç²—ç»†ï¼šä» style ä¸­è¯»å– fontWeight\r\n  // ç¡®ä¿è¿”å›æ•°å­—ç±»å‹ï¼Œå¦‚æœä¸æ˜¯ 300ã€400ã€600ï¼Œåˆ™æ˜ å°„åˆ°æœ€æ¥è¿‘çš„å€¼\r\n  const rawFontWeight = nodeStyle?.fontWeight\r\n    ? typeof nodeStyle.fontWeight === 'number'\r\n      ? nodeStyle.fontWeight\r\n      : typeof nodeStyle.fontWeight === 'string'\r\n        ? nodeStyle.fontWeight === 'normal'\r\n          ? 400\r\n          : nodeStyle.fontWeight === 'bold'\r\n            ? 600\r\n            : parseInt(nodeStyle.fontWeight)\r\n        : undefined\r\n    : undefined;\r\n  // æ˜ å°„åˆ°å…è®¸çš„å€¼ï¼š300ã€400ã€600\r\n  const fontWeight =\r\n    rawFontWeight !== undefined\r\n      ? rawFontWeight <= 350\r\n        ? 300\r\n        : rawFontWeight <= 500\r\n          ? 400\r\n          : 600\r\n      : undefined;\r\n\r\n  // å¦‚æœè®¾ç½®äº†èƒŒæ™¯è‰²ï¼Œéœ€è¦ç¡®ä¿å®ƒèƒ½å¤Ÿè¦†ç›–CSSçš„é»˜è®¤èƒŒæ™¯\r\n  // é€šè¿‡åœ¨å†…å±‚å®¹å™¨ä¸Šåº”ç”¨æ ·å¼æ¥å®ç°\r\n\r\n  // æ¯æ¬¡ data å˜åŒ–æ—¶åŒæ­¥ editValue å’Œ originalValue\r\n  useEffect(() => {\r\n    // åªæœ‰å½“å€¼çœŸæ­£å˜åŒ–æ—¶æ‰æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“\r\n    setEditValue((prev) => {\r\n      if (prev !== nodeData.name) return nodeData.name;\r\n      return prev;\r\n    });\r\n    setOriginalValue((prev) => {\r\n      if (prev !== nodeData.name) return nodeData.name;\r\n      return prev;\r\n    });\r\n  }, [nodeData.name]);\r\n\r\n  // è‡ªåŠ¨èšç„¦å’Œè°ƒæ•´é«˜åº¦\r\n  useEffect(() => {\r\n    if (isEditing && inputRef.current) {\r\n      const textarea = inputRef.current;\r\n      textarea.focus();\r\n      // ä¸è‡ªåŠ¨é€‰ä¸­å…¨éƒ¨æ–‡æœ¬ï¼Œå…è®¸ç”¨æˆ·ç‚¹å‡»å®šä½å…‰æ ‡ä½ç½®\r\n      // å°†å…‰æ ‡å®šä½åˆ°æ–‡æœ¬æœ«å°¾\r\n      const length = textarea.value.length;\r\n      textarea.setSelectionRange(length, length);\r\n      // è‡ªåŠ¨è°ƒæ•´ textarea é«˜åº¦ä»¥é€‚åº”å†…å®¹\r\n      textarea.style.height = 'auto';\r\n      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;\r\n\r\n      // æ·»åŠ åŸç”Ÿé”®ç›˜äº‹ä»¶ç›‘å¬å™¨ï¼Œåœ¨æ•è·é˜¶æ®µå¤„ç†ï¼Œç¡®ä¿ä¼˜å…ˆäºå…¶ä»–å¤„ç†å™¨\r\n      const handleNativeKeyDown = (e: KeyboardEvent) => {\r\n        // ESC é”®å–æ¶ˆç¼–è¾‘ï¼Œæ¢å¤åˆ°åŸå§‹å€¼\r\n        if (e.key === 'Escape') {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          setEditValue(originalValue);\r\n          setIsEditing(false);\r\n          return;\r\n        }\r\n\r\n        // Ctrl+Enter æˆ– Cmd+Enter æ¢è¡Œ\r\n        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {\r\n          // é˜»æ­¢äº‹ä»¶ç»§ç»­ä¼ æ’­å’Œé»˜è®¤è¡Œä¸º\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          // æ‰‹åŠ¨æ’å…¥æ¢è¡Œç¬¦\r\n          const start = textarea.selectionStart || 0;\r\n          const end = textarea.selectionEnd || 0;\r\n          const value = textarea.value || '';\r\n          const newValue = value.substring(0, start) + '\\n' + value.substring(end);\r\n          // ç›´æ¥æ›´æ–° textarea çš„å€¼\r\n          textarea.value = newValue;\r\n          // ä½¿ç”¨ React çš„ setter æ¥æ›´æ–°çŠ¶æ€ï¼Œç¡®ä¿çŠ¶æ€åŒæ­¥\r\n          setEditValue(newValue);\r\n          // è®¾ç½®å…‰æ ‡ä½ç½®åˆ°æ¢è¡Œç¬¦ä¹‹å\r\n          requestAnimationFrame(() => {\r\n            textarea.selectionStart = textarea.selectionEnd = start + 1;\r\n            // è‡ªåŠ¨è°ƒæ•´ textarea é«˜åº¦\r\n            textarea.style.height = 'auto';\r\n            textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;\r\n          });\r\n          return;\r\n        }\r\n\r\n        // Enter é”®æäº¤\r\n        if (e.key === 'Enter') {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          // ç›´æ¥è°ƒç”¨æäº¤é€»è¾‘\r\n          setIsEditing(false);\r\n          const trimmedValue = textarea.value.trim();\r\n          if (trimmedValue !== nodeData.name) {\r\n            setNodes((nodes) =>\r\n              nodes.map((node) => {\r\n                if (node.id === id) {\r\n                  return {\r\n                    ...node,\r\n                    data: { ...node.data, name: textarea.value },\r\n                  };\r\n                }\r\n                return node;\r\n              }),\r\n            );\r\n          }\r\n          return;\r\n        }\r\n      };\r\n\r\n      // åœ¨æ•è·é˜¶æ®µæ·»åŠ ç›‘å¬å™¨ï¼Œç¡®ä¿ä¼˜å…ˆå¤„ç†\r\n      textarea.addEventListener('keydown', handleNativeKeyDown, true);\r\n\r\n      return () => {\r\n        textarea.removeEventListener('keydown', handleNativeKeyDown, true);\r\n      };\r\n    }\r\n  }, [isEditing, originalValue, nodeData.name, id, setNodes]);\r\n\r\n  // æ¸…ç†åŠ¨ç”»å¸§\r\n  useEffect(() => {\r\n    return () => {\r\n      if (edgeUpdateFrameRef.current !== null) {\r\n        cancelAnimationFrame(edgeUpdateFrameRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const getNodeClassName = () => {\r\n    const baseClass = 'custom-flow-node';\r\n    const typeClass = `node-${nodeData.type}`;\r\n    const expandableClass = nodeData.expandable ? 'expandable' : '';\r\n    const selectedClass = selected ? 'selected' : '';\r\n    // å¦‚æœè®¾ç½®äº†è‡ªå®šä¹‰èƒŒæ™¯è‰²ï¼Œæ·»åŠ ä¸€ä¸ªç±»åä»¥è¦†ç›–é»˜è®¤èƒŒæ™¯\r\n    const customBgClass = backgroundColor ? 'has-custom-bg' : '';\r\n    // å¦‚æœæœ‰ç¼©ç•¥å›¾ï¼Œæ·»åŠ ä¸€ä¸ªç±»å\r\n    const hasScreenshotsClass = hasScreenshots ? 'has-screenshots' : '';\r\n\r\n    // ç»ˆæ­¢èŠ‚ç‚¹æ ¹æ®åç§°æˆ– subType åˆ¤æ–­æ˜¯å¼€å§‹è¿˜æ˜¯ç»“æŸ\r\n    let subTypeClass = '';\r\n    if (nodeData.type === 'terminator') {\r\n      if (nodeData.subType === 'start') {\r\n        subTypeClass = 'start';\r\n      } else if (nodeData.subType === 'end') {\r\n        subTypeClass = 'end';\r\n      } else if (nodeData.name === 'å¼€å§‹' || nodeData.name.toLowerCase().includes('start')) {\r\n        subTypeClass = 'start';\r\n      } else {\r\n        subTypeClass = 'end';\r\n      }\r\n    }\r\n\r\n    return `${baseClass} ${typeClass} ${subTypeClass} ${expandableClass} ${selectedClass} ${customBgClass} ${hasScreenshotsClass}`.trim();\r\n  };\r\n\r\n  const mergedStyle = {\r\n    ...nodeStyle,\r\n    ...(backgroundColor ? { backgroundColor } : {}),\r\n  };\r\n\r\n  // Handle æ ·å¼ä¼˜åŒ–ï¼šç™½è‰²å¡«å……ï¼Œæ·±è‰²è¾¹æ¡†ï¼Œç¨å¾®å¤§ä¸€ç‚¹\r\n  // source handle çš„ z-index æ›´é«˜ï¼Œç¡®ä¿åœ¨æ‹–æ‹½æ—¶ä¼˜å…ˆè¢«è¯†åˆ«\r\n  const sourceHandleStyle = {\r\n    width: 10,\r\n    height: 10,\r\n    background: '#fff',\r\n    border: '2px solid #64748b',\r\n    zIndex: 11, // source handle çš„ z-index æ›´é«˜\r\n  };\r\n\r\n  const targetHandleStyle = {\r\n    width: 10,\r\n    height: 10,\r\n    background: '#fff',\r\n    border: '2px solid #64748b',\r\n    zIndex: 10, // target handle çš„ z-index ç¨ä½\r\n  };\r\n\r\n  // åŒå‡»å¼€å§‹ç¼–è¾‘\r\n  const handleDoubleClick = (e: React.MouseEvent) => {\r\n    e.stopPropagation(); // é˜²æ­¢è§¦å‘ç”»å¸ƒçš„åŒå‡»äº‹ä»¶\r\n    setOriginalValue(nodeData.name); // ä¿å­˜ç¼–è¾‘å‰çš„åŸå§‹å€¼\r\n    setEditValue(nodeData.name); // é‡ç½®ç¼–è¾‘å€¼ä¸ºå½“å‰å€¼\r\n    setIsEditing(true);\r\n  };\r\n\r\n  // æäº¤ç¼–è¾‘\r\n  const handleSubmit = useCallback(() => {\r\n    setIsEditing(false);\r\n    if (editValue.trim() !== nodeData.name) {\r\n      setNodes((nodes) =>\r\n        nodes.map((node) => {\r\n          if (node.id === id) {\r\n            return {\r\n              ...node,\r\n              data: { ...node.data, name: editValue },\r\n            };\r\n          }\r\n          return node;\r\n        }),\r\n      );\r\n    }\r\n  }, [id, editValue, nodeData.name, setNodes]);\r\n\r\n  // å¤„ç†æ–‡æœ¬å˜åŒ–æ—¶è‡ªåŠ¨è°ƒæ•´é«˜åº¦\r\n  const handleTextareaChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n    setEditValue(e.target.value);\r\n    // è‡ªåŠ¨è°ƒæ•´ textarea é«˜åº¦ä»¥é€‚åº”å†…å®¹\r\n    const textarea = e.target;\r\n    textarea.style.height = 'auto';\r\n    textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;\r\n  }, []);\r\n\r\n  // é”®ç›˜äº‹ä»¶å¤„ç†å·²ç»ç§»åˆ°åŸç”Ÿäº‹ä»¶ç›‘å¬å™¨ä¸­ï¼Œè¿™é‡Œä¸éœ€è¦äº†\r\n\r\n  // æ£€æŸ¥æ˜¯å¦æœ‰ç¼©ç•¥å›¾\r\n  const hasScreenshots =\r\n    nodeData.detailConfig?.screenshots && nodeData.detailConfig.screenshots.length > 0;\r\n\r\n  // æ¸²æŸ“å†…å®¹åŒºåŸŸï¼ˆæ–‡æœ¬æˆ–è¾“å…¥æ¡†ï¼‰\r\n  const renderContent = () => (\r\n    <div className=\"node-content\" onDoubleClick={handleDoubleClick}>\r\n      {/* ç¼©ç•¥å›¾æ ‡è¯†å›¾æ ‡ */}\r\n      {hasScreenshots && (\r\n        <span className=\"node-screenshot-icon\" title=\"è¯¥èŠ‚ç‚¹åŒ…å«ç¼©ç•¥å›¾\">\r\n          ğŸ–¼ï¸\r\n        </span>\r\n      )}\r\n      {/* ä»…åœ¨é€‰ä¸­æ—¶æ˜¾ç¤ºè°ƒæ•´å¤§å°æ§åˆ¶å™¨ */}\r\n      <NodeResizer\r\n        color=\"#3b82f6\"\r\n        isVisible={selected}\r\n        minWidth={100}\r\n        minHeight={40}\r\n        // å¢å¤§æ§åˆ¶æ‰‹æŸ„å¤§å°ï¼Œä½¿å…¶æ›´å®¹æ˜“ç‚¹å‡»\r\n        handleStyle={{ width: 12, height: 12, borderRadius: '50%', border: '1px solid #fff' }}\r\n        lineStyle={{ borderWidth: 1, borderStyle: 'dashed' }}\r\n        onResize={(_, params) => {\r\n          const { width, height } = params;\r\n          // 1. æ›´æ–°èŠ‚ç‚¹æ ·å¼\r\n          setNodes((nodes) =>\r\n            nodes.map((node) => {\r\n              if (node.id === id) {\r\n                return {\r\n                  ...node,\r\n                  style: {\r\n                    ...node.style,\r\n                    width,\r\n                    height,\r\n                  },\r\n                };\r\n              }\r\n              return node;\r\n            }),\r\n          );\r\n\r\n          // 2. å…³é”®ï¼šé€šçŸ¥ React Flow æ›´æ–°èŠ‚ç‚¹å†…éƒ¨çŠ¶æ€ï¼ˆåŒ…æ‹¬ Handle ä½ç½®ï¼‰ï¼Œä»è€Œæ›´æ–°è¿çº¿\r\n          updateNodeInternals(id);\r\n        }}\r\n        onResizeEnd={(_, params) => {\r\n          const { width, height } = params;\r\n          // ç¡®ä¿æœ€ç»ˆçŠ¶æ€è¢«ä¿å­˜\r\n          setNodes((nodes) =>\r\n            nodes.map((node) => {\r\n              if (node.id === id) {\r\n                return {\r\n                  ...node,\r\n                  style: {\r\n                    ...node.style,\r\n                    width,\r\n                    height,\r\n                  },\r\n                };\r\n              }\r\n              return node;\r\n            }),\r\n          );\r\n          // å†æ¬¡æ›´æ–°ä»¥ç¡®ä¿æœ€ç»ˆä½ç½®æ­£ç¡®\r\n          updateNodeInternals(id);\r\n        }}\r\n      />\r\n      {nodeData.type === 'decision' ? (\r\n        <div className=\"diamond-shape\">\r\n          {/* SVG è±å½¢èƒŒæ™¯ */}\r\n          <svg\r\n            style={{\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100%',\r\n              height: '100%',\r\n              zIndex: 0,\r\n              overflow: 'hidden',\r\n              filter:\r\n                'drop-shadow(0 4px 6px -1px rgba(0, 0, 0, 0.1)) drop-shadow(0 2px 4px -1px rgba(0, 0, 0, 0.06))',\r\n            }}\r\n            viewBox=\"0 0 100 100\"\r\n            preserveAspectRatio=\"none\"\r\n          >\r\n            <defs>\r\n              <linearGradient id={`decisionGradient-${id}`} x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">\r\n                <stop offset=\"0%\" stopColor=\"#FFFFFF\" />\r\n                <stop offset=\"100%\" stopColor=\"#FFFFFF\" />\r\n              </linearGradient>\r\n            </defs>\r\n            <polygon\r\n              points=\"50,0 100,50 50,100 0,50\"\r\n              fill={backgroundColor || `url(#decisionGradient-${id})`}\r\n              stroke={(nodeStyle?.borderColor as string) || '#cbd5e1'}\r\n              strokeWidth={nodeStyle?.borderWidth ? `${nodeStyle.borderWidth}px` : '1px'}\r\n              strokeLinecap=\"round\"\r\n              strokeLinejoin=\"round\"\r\n            />\r\n          </svg>\r\n          {isEditing ? (\r\n            <textarea\r\n              ref={inputRef}\r\n              className=\"node-label-input nodrag\"\r\n              style={{\r\n                ...(fontSize ? { fontSize } : {}),\r\n                ...(fontColor ? { color: fontColor } : {}),\r\n                ...(fontFamily ? { fontFamily } : {}),\r\n                ...(fontWeight\r\n                  ? { fontWeight: fontWeight as React.CSSProperties['fontWeight'] }\r\n                  : {}),\r\n              }}\r\n              value={editValue}\r\n              onChange={handleTextareaChange}\r\n              onBlur={handleSubmit}\r\n              onClick={(e) => e.stopPropagation()}\r\n              rows={1}\r\n            />\r\n          ) : (\r\n            <span\r\n              className={`node-label ${hasScreenshots ? 'has-screenshots-label' : ''}`}\r\n              style={{\r\n                ...(fontSize ? { fontSize } : {}),\r\n                ...(fontColor ? { color: fontColor } : {}),\r\n                ...(fontFamily ? { fontFamily } : {}),\r\n                ...(fontWeight\r\n                  ? { fontWeight: fontWeight as React.CSSProperties['fontWeight'] }\r\n                  : {}),\r\n              }}\r\n            >\r\n              {nodeData.name}\r\n            </span>\r\n          )}\r\n        </div>\r\n      ) : nodeData.type === 'data' ? (\r\n        <div className=\"data-shape\">\r\n          {/* æ•°æ®èŠ‚ç‚¹ï¼šå¸¦ä¸¤æ¡å‚ç›´åˆ†å‰²çº¿çš„çŸ©å½¢ */}\r\n          <svg\r\n            style={{\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100%',\r\n              height: '100%',\r\n              zIndex: 0,\r\n              overflow: 'hidden',\r\n              filter:\r\n                'drop-shadow(0 4px 6px -1px rgba(0, 0, 0, 0.1)) drop-shadow(0 2px 4px -1px rgba(0, 0, 0, 0.06))',\r\n            }}\r\n            viewBox=\"0 0 100 100\"\r\n            preserveAspectRatio=\"none\"\r\n          >\r\n            <defs>\r\n              {/* æ•°æ®èŠ‚ç‚¹æ¸å˜èƒŒæ™¯ï¼Œä¸æµç¨‹èŠ‚ç‚¹é£æ ¼ä¸€è‡´ */}\r\n              <linearGradient id={`dataGradient-${id}`} x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">\r\n                <stop offset=\"0%\" stopColor=\"#ffffff\" />\r\n                <stop offset=\"100%\" stopColor=\"#ffffff\" />\r\n              </linearGradient>\r\n            </defs>\r\n            {/* å¤–æ¡†çŸ©å½¢ - ä½¿ç”¨åœ†è§’ï¼Œä¸æµç¨‹èŠ‚ç‚¹ä¸€è‡´ï¼Œå®Œå…¨å¡«å…… viewBox */}\r\n            <rect\r\n              x=\"0\"\r\n              y=\"0\"\r\n              width=\"100\"\r\n              height=\"100\"\r\n              rx=\"8\"\r\n              ry=\"8\"\r\n              fill={backgroundColor || `url(#dataGradient-${id})`}\r\n              stroke={(nodeStyle?.borderColor as string) || '#cbd5e1'}\r\n              strokeWidth={nodeStyle?.borderWidth ? `${nodeStyle.borderWidth}px` : '1px'}\r\n              strokeLinecap=\"round\"\r\n              strokeLinejoin=\"round\"\r\n            />\r\n            {/* å·¦ä¾§å‚ç›´åˆ†å‰²çº¿ - ä½¿ç”¨æµ…ç°è‰²ï¼Œä¸è¾¹æ¡†é¢œè‰²ä¸€è‡´ */}\r\n            <line\r\n              x1=\"15\"\r\n              y1=\"0\"\r\n              x2=\"15\"\r\n              y2=\"100\"\r\n              stroke=\"#cbd5e1\"\r\n              strokeWidth=\"1\"\r\n              strokeLinecap=\"round\"\r\n            />\r\n            {/* å³ä¾§å‚ç›´åˆ†å‰²çº¿ - ä½¿ç”¨æµ…ç°è‰²ï¼Œä¸è¾¹æ¡†é¢œè‰²ä¸€è‡´ */}\r\n            <line\r\n              x1=\"85\"\r\n              y1=\"0\"\r\n              x2=\"85\"\r\n              y2=\"100\"\r\n              stroke=\"#cbd5e1\"\r\n              strokeWidth=\"1\"\r\n              strokeLinecap=\"round\"\r\n            />\r\n          </svg>\r\n          {isEditing ? (\r\n            <textarea\r\n              ref={inputRef}\r\n              className=\"node-label-input nodrag\"\r\n              style={{\r\n                ...(fontSize ? { fontSize } : {}),\r\n                ...(fontColor ? { color: fontColor } : {}),\r\n                ...(fontFamily ? { fontFamily } : {}),\r\n                ...(fontWeight\r\n                  ? { fontWeight: fontWeight as React.CSSProperties['fontWeight'] }\r\n                  : {}),\r\n              }}\r\n              value={editValue}\r\n              onChange={handleTextareaChange}\r\n              onBlur={handleSubmit}\r\n              onClick={(e) => e.stopPropagation()}\r\n              rows={1}\r\n            />\r\n          ) : (\r\n            <span\r\n              className={`node-label ${hasScreenshots ? 'has-screenshots-label' : ''}`}\r\n              style={{\r\n                ...(fontSize ? { fontSize } : {}),\r\n                ...(fontColor ? { color: fontColor } : {}),\r\n                ...(fontFamily ? { fontFamily } : {}),\r\n                ...(fontWeight\r\n                  ? { fontWeight: fontWeight as React.CSSProperties['fontWeight'] }\r\n                  : {}),\r\n              }}\r\n            >\r\n              {nodeData.name}\r\n            </span>\r\n          )}\r\n        </div>\r\n      ) : (\r\n        <>\r\n          {isEditing ? (\r\n            <textarea\r\n              ref={inputRef}\r\n              className=\"node-label-input nodrag\"\r\n              style={{\r\n                ...(fontSize ? { fontSize } : {}),\r\n                ...(fontColor ? { color: fontColor } : {}),\r\n                ...(fontFamily ? { fontFamily } : {}),\r\n                ...(fontWeight\r\n                  ? { fontWeight: fontWeight as React.CSSProperties['fontWeight'] }\r\n                  : {}),\r\n              }}\r\n              value={editValue}\r\n              onChange={handleTextareaChange}\r\n              onBlur={handleSubmit}\r\n              onClick={(e) => e.stopPropagation()}\r\n              rows={1}\r\n            />\r\n          ) : (\r\n            <span\r\n              className={`node-label ${hasScreenshots ? 'has-screenshots-label' : ''}`}\r\n              style={{\r\n                ...(fontSize ? { fontSize } : {}),\r\n                ...(fontColor ? { color: fontColor } : {}),\r\n                ...(fontFamily ? { fontFamily } : {}),\r\n                ...(fontWeight\r\n                  ? { fontWeight: fontWeight as React.CSSProperties['fontWeight'] }\r\n                  : {}),\r\n              }}\r\n            >\r\n              {nodeData.name}\r\n            </span>\r\n          )}\r\n        </>\r\n      )}\r\n    </div>\r\n  );\r\n\r\n  // åˆ¤æ–­èŠ‚ç‚¹éœ€è¦ç‰¹æ®Šå¤„ç†\r\n  // åˆ¤æ–­èŠ‚ç‚¹çš„å¤–å±‚å®¹å™¨åº”è¯¥ä¿æŒé€æ˜ï¼Œåªæœ‰SVGçš„fillä¼šæ”¹å˜\r\n  if (nodeData.type === 'decision') {\r\n    // å¯¹äºåˆ¤æ–­èŠ‚ç‚¹ï¼Œä¸åº”ç”¨èƒŒæ™¯è‰²åˆ°å®¹å™¨ï¼Œåªåº”ç”¨åˆ°SVG\r\n    const decisionStyle = nodeStyle ? { ...nodeStyle } : {};\r\n    // ç§»é™¤èƒŒæ™¯è‰²ç›¸å…³å±æ€§ï¼Œä¿æŒå®¹å™¨é€æ˜\r\n    delete decisionStyle.background;\r\n    delete decisionStyle.backgroundColor;\r\n    // è¾¹æ¡†é¢œè‰²å’Œç²—ç»†ä¼šåº”ç”¨åˆ°SVGçš„strokeä¸Šï¼Œä¸éœ€è¦åœ¨å®¹å™¨ä¸Šåº”ç”¨\r\n\r\n    return (\r\n      <div className={getNodeClassName()} style={decisionStyle}>\r\n        {/* Top - å®šä½åˆ°é¡¶éƒ¨é¡¶ç‚¹ */}\r\n        {/* source handle åœ¨å‰ï¼Œç¡®ä¿åœ¨æ‹–æ‹½æ—¶ä¼˜å…ˆè¢«è¯†åˆ« */}\r\n        <Handle id=\"top-source\" type=\"source\" position={Position.Top} style={sourceHandleStyle} />\r\n        <Handle id=\"top-target\" type=\"target\" position={Position.Top} style={targetHandleStyle} />\r\n        {/* Right - å®šä½åˆ°å³ä¾§é¡¶ç‚¹ */}\r\n        <Handle id=\"right\" type=\"source\" position={Position.Right} style={sourceHandleStyle} />\r\n        <Handle\r\n          id=\"right-target\"\r\n          type=\"target\"\r\n          position={Position.Right}\r\n          style={targetHandleStyle}\r\n        />\r\n        {/* Bottom - å®šä½åˆ°åº•éƒ¨é¡¶ç‚¹ */}\r\n        <Handle id=\"bottom\" type=\"source\" position={Position.Bottom} style={sourceHandleStyle} />\r\n        <Handle\r\n          id=\"bottom-target\"\r\n          type=\"target\"\r\n          position={Position.Bottom}\r\n          style={targetHandleStyle}\r\n        />\r\n        {/* Left - å®šä½åˆ°å·¦ä¾§é¡¶ç‚¹ */}\r\n        <Handle id=\"left\" type=\"source\" position={Position.Left} style={sourceHandleStyle} />\r\n        <Handle id=\"left-target\" type=\"target\" position={Position.Left} style={targetHandleStyle} />\r\n\r\n        {renderContent()}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // æ•°æ®èŠ‚ç‚¹éœ€è¦ç‰¹æ®Šå¤„ç†\r\n  // æ•°æ®èŠ‚ç‚¹çš„å¤–å±‚å®¹å™¨åº”è¯¥ä¿æŒé€æ˜ï¼Œåªæœ‰SVGçš„fillå’Œçº¿æ¡ä¼šæ˜¾ç¤º\r\n  if (nodeData.type === 'data') {\r\n    // å¯¹äºæ•°æ®èŠ‚ç‚¹ï¼Œä¸åº”ç”¨èƒŒæ™¯è‰²åˆ°å®¹å™¨ï¼Œåªåº”ç”¨åˆ°SVG\r\n    const dataStyle = nodeStyle ? { ...nodeStyle } : {};\r\n    // ç§»é™¤èƒŒæ™¯è‰²ç›¸å…³å±æ€§ï¼Œä¿æŒå®¹å™¨é€æ˜\r\n    delete dataStyle.background;\r\n    delete dataStyle.backgroundColor;\r\n    // è¾¹æ¡†é¢œè‰²å’Œç²—ç»†ä¼šåº”ç”¨åˆ°SVGçš„strokeä¸Šï¼Œä¸éœ€è¦åœ¨å®¹å™¨ä¸Šåº”ç”¨\r\n\r\n    return (\r\n      <div className={getNodeClassName()} style={dataStyle}>\r\n        {/* Top */}\r\n        <Handle id=\"top-source\" type=\"source\" position={Position.Top} style={sourceHandleStyle} />\r\n        <Handle id=\"top-target\" type=\"target\" position={Position.Top} style={targetHandleStyle} />\r\n        {/* Left */}\r\n        <Handle id=\"left\" type=\"source\" position={Position.Left} style={sourceHandleStyle} />\r\n        <Handle id=\"left-target\" type=\"target\" position={Position.Left} style={targetHandleStyle} />\r\n        {/* Right */}\r\n        <Handle id=\"right\" type=\"source\" position={Position.Right} style={sourceHandleStyle} />\r\n        <Handle\r\n          id=\"right-target\"\r\n          type=\"target\"\r\n          position={Position.Right}\r\n          style={targetHandleStyle}\r\n        />\r\n\r\n        {renderContent()}\r\n\r\n        {/* Bottom */}\r\n        <Handle id=\"bottom\" type=\"source\" position={Position.Bottom} style={sourceHandleStyle} />\r\n        <Handle\r\n          id=\"bottom-target\"\r\n          type=\"target\"\r\n          position={Position.Bottom}\r\n          style={targetHandleStyle}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // å¤„ç†èŠ‚ç‚¹å’Œç»ˆæ­¢èŠ‚ç‚¹\r\n  return (\r\n    <div className={getNodeClassName()} style={mergedStyle}>\r\n      {/* Top */}\r\n      {/* source handle åœ¨å‰ï¼Œç¡®ä¿åœ¨æ‹–æ‹½æ—¶ä¼˜å…ˆè¢«è¯†åˆ« */}\r\n      <Handle id=\"top-source\" type=\"source\" position={Position.Top} style={sourceHandleStyle} />\r\n      <Handle id=\"top-target\" type=\"target\" position={Position.Top} style={targetHandleStyle} />\r\n      {/* Left */}\r\n      <Handle id=\"left\" type=\"source\" position={Position.Left} style={sourceHandleStyle} />\r\n      <Handle id=\"left-target\" type=\"target\" position={Position.Left} style={targetHandleStyle} />\r\n      {/* Right */}\r\n      <Handle id=\"right\" type=\"source\" position={Position.Right} style={sourceHandleStyle} />\r\n      <Handle id=\"right-target\" type=\"target\" position={Position.Right} style={targetHandleStyle} />\r\n\r\n      {renderContent()}\r\n\r\n      {/* Bottom */}\r\n      <Handle id=\"bottom\" type=\"source\" position={Position.Bottom} style={sourceHandleStyle} />\r\n      <Handle\r\n        id=\"bottom-target\"\r\n        type=\"target\"\r\n        position={Position.Bottom}\r\n        style={targetHandleStyle}\r\n      />\r\n    </div>\r\n  );\r\n});\r\n\r\nCustomNode.displayName = 'CustomNode';\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\DraggableEdge\\index.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/set-state-in-effect",
        "severity": 2,
        "message": "Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nE:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\DraggableEdge\\index.tsx:41:5\n  39 |   // æ£€æŸ¥å½“å‰ edge æ˜¯å¦è¢«é€‰ä¸­ - ä½¿ç”¨ fullEdge çš„ selected å±æ€§\n  40 |   useEffect(() => {\n> 41 |     setIsSelected(fullEdge?.selected || false);\n     |     ^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  42 |   }, [fullEdge?.selected]);\n  43 |\n  44 |   // ä» data ä¸­è¯»å–åç§»é‡ï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤ä¸º 0",
        "line": 41,
        "column": 5,
        "nodeType": null,
        "endLine": 41,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'isDragging' is assigned a value but never used.",
        "line": 263,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 263,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onMouseDown' is assigned a value but never used.",
        "line": 267,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 267,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useCallback, useRef, useState, useMemo, useEffect } from 'react';\r\nimport {\r\n  BaseEdge,\r\n  EdgeLabelRenderer,\r\n  EdgeProps,\r\n  getSmoothStepPath,\r\n  getStraightPath,\r\n  useReactFlow,\r\n  Position,\r\n} from '@xyflow/react';\r\nimport './styles.css';\r\n\r\n// è¿™ä¸ªç»„ä»¶å°†æ›¿ä»£é»˜è®¤çš„ Edge\r\nexport default function DraggableEdge({\r\n  id,\r\n  sourceX,\r\n  sourceY,\r\n  targetX,\r\n  targetY,\r\n  sourcePosition,\r\n  targetPosition,\r\n  style = {},\r\n  markerEnd,\r\n  markerStart, // æ¥æ”¶ markerStart\r\n  data,\r\n  label,\r\n  labelStyle,\r\n  labelBgStyle,\r\n}: EdgeProps) {\r\n  const { setEdges, getZoom, getEdge } = useReactFlow();\r\n  const [isHovered, setIsHovered] = useState(false);\r\n  const [isSelected, setIsSelected] = useState(false);\r\n\r\n  // ä» React Flow è·å–å®Œæ•´çš„ edge å¯¹è±¡ï¼Œç¡®ä¿è·å–åˆ° labelStyle å’Œ labelBgStyle\r\n  // React Flow å¯èƒ½ä¸ä¼šè‡ªåŠ¨å°† labelStyle å’Œ labelBgStyle ä½œä¸º props ä¼ é€’\r\n  // æ¯æ¬¡æ¸²æŸ“æ—¶éƒ½è·å–æœ€æ–°çš„ edge å¯¹è±¡\r\n  const fullEdge = getEdge(id);\r\n\r\n  // æ£€æŸ¥å½“å‰ edge æ˜¯å¦è¢«é€‰ä¸­ - ä½¿ç”¨ fullEdge çš„ selected å±æ€§\r\n  useEffect(() => {\r\n    setIsSelected(fullEdge?.selected || false);\r\n  }, [fullEdge?.selected]);\r\n\r\n  // ä» data ä¸­è¯»å–åç§»é‡ï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤ä¸º 0\r\n  const offset = (data?.offset as number) || 0;\r\n\r\n\r\n  // è®¡ç®—ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„å®é™…è·ç¦»\r\n  const dx = Math.abs(targetX - sourceX);\r\n  const dy = Math.abs(targetY - sourceY);\r\n  const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  // æ ¹æ®è·ç¦»åŠ¨æ€è®¡ç®—è·¯å¾„ï¼Œé¿å…èŠ‚ç‚¹è·ç¦»è¿‡è¿‘æ—¶è·¯å¾„é‡å \r\n  // è·¯å¾„æ­£å¸¸ä» source åˆ° targetï¼ŒmarkerEnd ä¼šåœ¨è·¯å¾„ç»ˆç‚¹ï¼ˆtarget ä½ç½®ï¼‰ï¼ŒmarkerStart ä¼šåœ¨è·¯å¾„èµ·ç‚¹ï¼ˆsource ä½ç½®ï¼‰\r\n  const { edgePath, labelX, labelY } = useMemo(() => {\r\n    // å¦‚æœè·ç¦»éå¸¸è¿‘ï¼ˆå°äº 30pxï¼‰ï¼Œä½¿ç”¨ç›´çº¿è·¯å¾„\r\n    if (distance < 30) {\r\n      const [path, labelX, labelY] = getStraightPath({\r\n        sourceX: sourceX,\r\n        sourceY: sourceY,\r\n        targetX: targetX,\r\n        targetY: targetY,\r\n      });\r\n      return { edgePath: path, labelX, labelY };\r\n    }\r\n\r\n    // æ ¹æ®è·ç¦»åŠ¨æ€è°ƒæ•´ offset\r\n    let dynamicOffset = 20 + offset;\r\n    if (distance < 50) {\r\n      // è·ç¦»è¾ƒè¿‘ï¼Œå‡å° offsetï¼Œé¿å…è·¯å¾„é‡å \r\n      dynamicOffset = Math.max(5, Math.min(distance / 2.5, 20 + offset));\r\n    }\r\n\r\n    // ä½¿ç”¨å¹³æ»‘è·¯å¾„\r\n    const [path, labelX, labelY] = getSmoothStepPath({\r\n      sourceX: sourceX, // ä» source å¼€å§‹\r\n      sourceY: sourceY,\r\n      sourcePosition: sourcePosition,\r\n      targetX: targetX, // åˆ° target ç»“æŸ\r\n      targetY: targetY,\r\n      targetPosition: targetPosition,\r\n      borderRadius: 0,\r\n      offset: dynamicOffset,\r\n    });\r\n    return { edgePath: path, labelX, labelY };\r\n  }, [sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, offset, distance]);\r\n\r\n  // ç›´æ¥ä» fullEdge è¯»å–æ ·å¼ï¼Œç¡®ä¿è·å–æœ€æ–°å€¼\r\n  // ä¼˜å…ˆä½¿ç”¨ propsï¼Œç„¶åä½¿ç”¨ edge å¯¹è±¡ä¸­çš„å€¼\r\n  const currentLabelStyle = labelStyle || fullEdge?.labelStyle;\r\n  const currentLabelBgStyle = labelBgStyle || fullEdge?.labelBgStyle;\r\n\r\n  // è®¡ç®—èƒŒæ™¯é€æ˜åº¦ï¼šä» labelBgStyle.fillOpacity è¯»å–\r\n  const bgOpacity =\r\n    typeof currentLabelBgStyle?.fillOpacity === 'number' ? currentLabelBgStyle.fillOpacity : 1; // é»˜è®¤å®Œå…¨ä¸é€æ˜\r\n\r\n  // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º rgba æ ¼å¼ï¼Œåº”ç”¨é€æ˜åº¦\r\n  const hexToRgba = (hex: string, opacity: number): string => {\r\n    // ç§»é™¤ # å·\r\n    const cleanHex = hex.replace('#', '');\r\n    // è§£æ RGB å€¼\r\n    const r = parseInt(cleanHex.substring(0, 2), 16);\r\n    const g = parseInt(cleanHex.substring(2, 4), 16);\r\n    const b = parseInt(cleanHex.substring(4, 6), 16);\r\n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\r\n  };\r\n\r\n  // è·å–èƒŒæ™¯è‰²\r\n  const bgColor = (currentLabelBgStyle?.fill ||\r\n    currentLabelStyle?.background ||\r\n    '#E0E0E0') as string;\r\n  // å°†èƒŒæ™¯è‰²è½¬æ¢ä¸º rgba æ ¼å¼ï¼Œåº”ç”¨é€æ˜åº¦\r\n  const backgroundColorWithOpacity = bgColor.startsWith('#')\r\n    ? hexToRgba(bgColor, bgOpacity)\r\n    : bgColor; // å¦‚æœå·²ç»æ˜¯ rgba æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨\r\n\r\n  // è¯»å–èƒŒæ™¯å¤§å°\r\n  const bgWidth = currentLabelBgStyle?.width;\r\n  const bgHeight = currentLabelBgStyle?.height;\r\n  // è¯»å–æ˜¯å¦ä¸ºè‡ªåŠ¨æ¨¡å¼ï¼ˆå¦‚æœæ ‡è®°å­˜åœ¨ä¸”ä¸º trueï¼Œåˆ™ä¸ºè‡ªåŠ¨æ¨¡å¼ï¼‰\r\n  const widthAuto = currentLabelBgStyle?.widthAuto === true;\r\n  const heightAuto = currentLabelBgStyle?.heightAuto === true;\r\n\r\n  // è§£æ padding å€¼ï¼Œè®¡ç®—å¯ç”¨ç©ºé—´\r\n  const parsePadding = (\r\n    paddingStr: string,\r\n  ): { top: number; right: number; bottom: number; left: number } => {\r\n    // é»˜è®¤ padding: '6px 12px' (ä¸Šä¸‹ 6px, å·¦å³ 12px)\r\n    const parts = paddingStr.trim().split(/\\s+/);\r\n    if (parts.length === 2) {\r\n      // '6px 12px' -> ä¸Šä¸‹ 6px, å·¦å³ 12px\r\n      const vertical = parseFloat(parts[0]) || 6;\r\n      const horizontal = parseFloat(parts[1]) || 12;\r\n      return { top: vertical, right: horizontal, bottom: vertical, left: horizontal };\r\n    } else if (parts.length === 4) {\r\n      // '6px 12px 6px 12px' -> ä¸Š å³ ä¸‹ å·¦\r\n      return {\r\n        top: parseFloat(parts[0]) || 6,\r\n        right: parseFloat(parts[1]) || 12,\r\n        bottom: parseFloat(parts[2]) || 6,\r\n        left: parseFloat(parts[3]) || 12,\r\n      };\r\n    }\r\n    // é»˜è®¤å€¼\r\n    return { top: 6, right: 12, bottom: 6, left: 12 };\r\n  };\r\n\r\n  const paddingStr = (currentLabelStyle?.padding || '6px 12px') as string;\r\n  const padding = parsePadding(paddingStr);\r\n\r\n  // è·å–åŸå§‹å­—ä½“å¤§å°\r\n  const originalFontSize =\r\n    typeof currentLabelStyle?.fontSize === 'number'\r\n      ? currentLabelStyle.fontSize\r\n      : typeof currentLabelStyle?.fontSize === 'string'\r\n        ? parseFloat(currentLabelStyle.fontSize) || 9\r\n        : 9;\r\n\r\n  // è®¡ç®—åŠ¨æ€å­—ä½“å¤§å°ï¼ˆåªæœ‰å½“ç”¨æˆ·æ‰‹åŠ¨è®¾ç½®èƒŒæ™¯å¤§å°æ—¶æ‰çº¦æŸå­—ä½“å¤§å°ï¼‰\r\n  // å¦‚æœæ˜¯ auto æ¨¡å¼ï¼ŒèƒŒæ™¯ä¼šè‡ªåŠ¨é€‚åº”å­—ä½“å¤§å°ï¼Œä¸éœ€è¦çº¦æŸå­—ä½“\r\n  let calculatedFontSize = originalFontSize;\r\n  const MIN_FONT_SIZE = 6; // æœ€å°å­—ä½“å¤§å°\r\n\r\n  // åªæœ‰å½“å®½åº¦æˆ–é«˜åº¦æ˜¯æ‰‹åŠ¨è®¾ç½®çš„ï¼ˆé auto æ¨¡å¼ï¼‰æ—¶ï¼Œæ‰è¿›è¡Œå­—ä½“å¤§å°çº¦æŸ\r\n  const hasManualWidth = bgWidth !== undefined && !widthAuto;\r\n  const hasManualHeight = bgHeight !== undefined && !heightAuto;\r\n\r\n  if (hasManualWidth || hasManualHeight) {\r\n    // è®¡ç®—å¯ç”¨ç©ºé—´ï¼ˆåªå¯¹æ‰‹åŠ¨è®¾ç½®çš„ç»´åº¦è¿›è¡Œçº¦æŸï¼‰\r\n    const availableWidth = hasManualWidth\r\n      ? (typeof bgWidth === 'number' ? bgWidth : parseFloat(String(bgWidth))) -\r\n      padding.left -\r\n      padding.right\r\n      : Infinity;\r\n    const availableHeight = hasManualHeight\r\n      ? (typeof bgHeight === 'number' ? bgHeight : parseFloat(String(bgHeight))) -\r\n      padding.top -\r\n      padding.bottom\r\n      : Infinity;\r\n\r\n    // æ ¹æ®æ–‡å­—é•¿åº¦ä¼°ç®—æ‰€éœ€å®½åº¦ï¼ˆä¸­æ–‡å­—ç¬¦çº¦ç­‰äºå­—ä½“å¤§å°çš„ 1.2 å€ï¼Œè‹±æ–‡å­—ç¬¦çº¦ç­‰äºå­—ä½“å¤§å°çš„ 0.6 å€ï¼‰\r\n    const labelText = typeof label === 'string' ? label : '';\r\n    const chineseCharCount = (labelText.match(/[\\u4e00-\\u9fa5]/g) || []).length;\r\n    const englishCharCount = labelText.length - chineseCharCount;\r\n\r\n    // ä¼°ç®—æ¯ä¸ªå­—ç¬¦çš„å¹³å‡å®½åº¦ï¼ˆåŸºäºåŸå§‹å­—ä½“å¤§å°ï¼‰\r\n    const avgCharWidthRatio =\r\n      chineseCharCount > 0\r\n        ? (chineseCharCount * 1.2 + englishCharCount * 0.6) / labelText.length\r\n        : 0.6;\r\n\r\n    // æ ¹æ®å®½åº¦è®¡ç®—å­—ä½“å¤§å°ï¼ˆåªå¯¹æ‰‹åŠ¨è®¾ç½®å®½åº¦æ—¶è®¡ç®—ï¼‰\r\n    let fontSizeByWidth = originalFontSize;\r\n    if (hasManualWidth && availableWidth !== Infinity && labelText.length > 0) {\r\n      fontSizeByWidth = availableWidth / (labelText.length * avgCharWidthRatio);\r\n    }\r\n\r\n    // æ ¹æ®é«˜åº¦è®¡ç®—å­—ä½“å¤§å°ï¼ˆåªå¯¹æ‰‹åŠ¨è®¾ç½®é«˜åº¦æ—¶è®¡ç®—ï¼‰\r\n    let fontSizeByHeight = originalFontSize;\r\n    if (hasManualHeight && availableHeight !== Infinity) {\r\n      fontSizeByHeight = availableHeight / 1.2;\r\n    }\r\n\r\n    // å–ä¸¤è€…ä¸­çš„è¾ƒå°å€¼ï¼Œç¡®ä¿æ–‡å­—èƒ½å®Œå…¨æ˜¾ç¤º\r\n    calculatedFontSize = Math.min(fontSizeByWidth, fontSizeByHeight, originalFontSize);\r\n\r\n    // ç¡®ä¿ä¸å°äºæœ€å°å­—ä½“å¤§å°\r\n    calculatedFontSize = Math.max(calculatedFontSize, MIN_FONT_SIZE);\r\n  }\r\n\r\n  // è®¡ç®—æœ€ç»ˆçš„æ ‡ç­¾æ ·å¼\r\n  const labelStyles: React.CSSProperties = {\r\n    color: (currentLabelStyle?.fill || currentLabelStyle?.color || '#000000') as string,\r\n    fontSize: `${calculatedFontSize}px`,\r\n    fontWeight: (() => {\r\n      // è¯»å–å­—ä½“ç²—ç»†ï¼Œå¦‚æœä¸æ˜¯ 300ã€400ã€600ï¼Œåˆ™æ˜ å°„åˆ°æœ€æ¥è¿‘çš„å€¼\r\n      const rawFontWeight =\r\n        typeof currentLabelStyle?.fontWeight === 'number'\r\n          ? currentLabelStyle.fontWeight\r\n          : typeof currentLabelStyle?.fontWeight === 'string'\r\n            ? parseInt(currentLabelStyle.fontWeight) || 300\r\n            : 300;\r\n      // æ˜ å°„åˆ°å…è®¸çš„å€¼ï¼š300ã€400ã€600\r\n      return rawFontWeight <= 350 ? 300 : rawFontWeight <= 500 ? 400 : 600;\r\n    })(),\r\n    fontFamily: (currentLabelStyle?.fontFamily || 'å¾®è½¯é›…é»‘') as string,\r\n    backgroundColor: backgroundColorWithOpacity, // åº”ç”¨é€æ˜åº¦çš„èƒŒæ™¯è‰²\r\n    padding: paddingStr,\r\n    borderRadius:\r\n      typeof currentLabelStyle?.borderRadius === 'number'\r\n        ? `${currentLabelStyle.borderRadius}px`\r\n        : typeof currentLabelStyle?.borderRadius === 'string'\r\n          ? currentLabelStyle.borderRadius.includes('px')\r\n            ? currentLabelStyle.borderRadius\r\n            : `${currentLabelStyle.borderRadius}px`\r\n          : '6px',\r\n    // ç¡®ä¿æ–‡å­—ä¸è¶…å‡ºèƒŒæ™¯\r\n    overflow: 'hidden',\r\n    textOverflow: 'ellipsis',\r\n    whiteSpace: 'nowrap',\r\n    display: 'flex',\r\n    alignItems: 'center',\r\n    justifyContent: 'center',\r\n  };\r\n\r\n  // å¦‚æœè®¾ç½®äº†èƒŒæ™¯å¤§å°ï¼Œåº”ç”¨åˆ°æ ·å¼\r\n  // ä½¿ç”¨ width å’Œ height è€Œä¸æ˜¯ minWidth/minHeightï¼Œç¡®ä¿è®¾ç½®çš„å€¼èƒ½å¤Ÿç”Ÿæ•ˆ\r\n  if (bgWidth !== undefined) {\r\n    labelStyles.width = typeof bgWidth === 'number' ? `${bgWidth}px` : bgWidth;\r\n    // åŒæ—¶è®¾ç½® box-sizing ä¸º border-boxï¼Œç¡®ä¿ width åŒ…å« padding\r\n    labelStyles.boxSizing = 'border-box';\r\n  }\r\n  if (bgHeight !== undefined) {\r\n    labelStyles.height = typeof bgHeight === 'number' ? `${bgHeight}px` : bgHeight;\r\n    // åŒæ—¶è®¾ç½® box-sizing ä¸º border-boxï¼Œç¡®ä¿ height åŒ…å« padding\r\n    labelStyles.boxSizing = 'border-box';\r\n  }\r\n\r\n  // åˆ¤æ–­è¿çº¿çš„ä¸»è¦æ–¹å‘\r\n  const isHorizontalFlow = sourcePosition === Position.Left || sourcePosition === Position.Right;\r\n\r\n  // æ‹–æ‹½é€»è¾‘ - ä½¿ç”¨ useState æ¥è¿½è¸ªæ‹–æ‹½çŠ¶æ€ä»¥ä¾¿åœ¨æ¸²æŸ“ä¸­ä½¿ç”¨\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const draggingRef = useRef(false);\r\n  const lastPosRef = useRef(0);\r\n\r\n  const onMouseDown = useCallback(\r\n    (evt: React.MouseEvent) => {\r\n      // é˜»æ­¢å†’æ³¡ï¼Œé˜²æ­¢ç”»å¸ƒæ‹–æ‹½\r\n      evt.stopPropagation();\r\n      // é˜»æ­¢é»˜è®¤è¡Œä¸º\r\n      evt.preventDefault();\r\n\r\n      // 1. æ‰‹åŠ¨é€‰ä¸­å½“å‰è¿çº¿ï¼ˆå®ç°ç‚¹å‡»å³é€‰ä¸­ï¼‰\r\n      setEdges((edges) =>\r\n        edges.map((e) => ({\r\n          ...e,\r\n          selected: e.id === id,\r\n        })),\r\n      );\r\n\r\n      // 2. ç«‹å³å¼€å§‹æ‹–æ‹½\r\n      draggingRef.current = true;\r\n      setIsDragging(true); // è§¦å‘é‡æ¸²æŸ“ä»¥æ›´æ–°æ ·å¼\r\n      // è®°å½•åˆå§‹é¼ æ ‡ä½ç½®\r\n      lastPosRef.current = isHorizontalFlow ? evt.clientX : evt.clientY;\r\n\r\n      // æ·»åŠ æ‹–æ‹½ä¸­çš„è§†è§‰åé¦ˆ\r\n      const handleElement = evt.currentTarget as HTMLElement;\r\n      const originalTransform = handleElement.style.transform;\r\n\r\n      const onMouseMove = (moveEvt: MouseEvent) => {\r\n        if (!draggingRef.current) return;\r\n\r\n        const currentPos = isHorizontalFlow ? moveEvt.clientX : moveEvt.clientY;\r\n        const zoom = getZoom();\r\n        // è®¡ç®—ç§»åŠ¨è·ç¦»ï¼Œé™¤ä»¥ç¼©æ”¾æ¯”ä¾‹ä»¥ä¿æŒä¸€è‡´\r\n        const diff = (currentPos - lastPosRef.current) / zoom;\r\n\r\n        lastPosRef.current = currentPos;\r\n\r\n        // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ€§èƒ½ï¼Œä½¿æ‹–æ‹½æ›´æµç•…\r\n        requestAnimationFrame(() => {\r\n          setEdges((edges) =>\r\n            edges.map((e) => {\r\n              if (e.id === id) {\r\n                const currentOffset = (e.data?.offset as number) || 0;\r\n                return {\r\n                  ...e,\r\n                  data: { ...e.data, offset: currentOffset + diff },\r\n                };\r\n              }\r\n              return e;\r\n            }),\r\n          );\r\n        });\r\n      };\r\n\r\n      const onMouseUp = () => {\r\n        draggingRef.current = false;\r\n        setIsDragging(false);\r\n        // æ¢å¤æ‹–æ‹½æ‰‹æŸ„çš„æ ·å¼\r\n        if (handleElement) {\r\n          handleElement.style.transform = originalTransform;\r\n        }\r\n        document.removeEventListener('mousemove', onMouseMove);\r\n        document.removeEventListener('mouseup', onMouseUp);\r\n      };\r\n\r\n      document.addEventListener('mousemove', onMouseMove);\r\n      document.addEventListener('mouseup', onMouseUp);\r\n    },\r\n    [id, setEdges, getZoom, isHorizontalFlow],\r\n  );\r\n\r\n  // åˆ¤æ–­ç®­å¤´æ–¹å‘ï¼Œç”¨äºåè½¬åŠ¨ç”»\r\n  const hasOnlyStartMarker = markerStart && !markerEnd;\r\n\r\n  // æ‚¬åœæˆ–é€‰ä¸­æ—¶åŠ ç²—çº¿æ¡å¹¶æ”¹å˜é¢œè‰²\r\n  // å¦‚æœæœªå®ç°ï¼Œä½¿ç”¨è™šçº¿æ ·å¼\r\n  const edgeStyle = {\r\n    ...style,\r\n    ...(hasOnlyStartMarker ? { animationDirection: 'reverse' as const } : {}),\r\n    strokeWidth: isSelected\r\n      ? ((style.strokeWidth as number) || 1) * 2\r\n      : isHovered\r\n        ? ((style.strokeWidth as number) || 1) * 1.5\r\n        : style.strokeWidth || 1,\r\n    stroke: isSelected ? '#3b82f6' : isHovered ? '#60a5fa' : style.stroke || '#64748b',\r\n    strokeDasharray: style.strokeDasharray,\r\n    transition: 'stroke 0.2s, stroke-width 0.2s',\r\n  };\r\n\r\n  return (\r\n    <g\r\n      onMouseEnter={() => setIsHovered(true)}\r\n      onMouseLeave={() => setIsHovered(false)}\r\n      className={hasOnlyStartMarker ? 'edge-reverse-animation' : ''}\r\n    >\r\n      {/* å®é™…æ˜¾ç¤ºçš„è¿çº¿ï¼Œä¼ å…¥ markerStart å’Œ markerEnd */}\r\n      <BaseEdge path={edgePath} markerEnd={markerEnd} markerStart={markerStart} style={edgeStyle} />\r\n\r\n      <EdgeLabelRenderer>\r\n        {/* è¿çº¿æ–‡å­— (å¦‚æœå­˜åœ¨) - æ”¾åœ¨æ‹–æ‹½æ‰‹æŸ„å‰é¢ï¼Œç¡®ä¿æ–‡å­—åœ¨ä¸Šå±‚ */}\r\n        {label && (\r\n          <div\r\n            style={{\r\n              position: 'absolute',\r\n              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\r\n              ...labelStyles,\r\n              pointerEvents: 'all',\r\n              zIndex: 20, // ç¡®ä¿æ ‡ç­¾åœ¨æ‹–æ‹½æ‰‹æŸ„ä¹‹ä¸Š\r\n            }}\r\n            className=\"nodrag nopan edge-label\"\r\n          >\r\n            {label}\r\n          </div>\r\n        )}\r\n      </EdgeLabelRenderer>\r\n    </g>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\FloatingEdge\\index.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Node' is defined but never used.",
        "line": 8,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 30,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 30,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": {
              "range": [
                659,
                662
              ],
              "text": "unknown"
            },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": {
              "range": [
                659,
                662
              ],
              "text": "never"
            },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useMemo } from 'react';\r\nimport {\r\n  BaseEdge,\r\n  EdgeLabelRenderer,\r\n  getSmoothStepPath,\r\n  useInternalNode,\r\n  Position,\r\n  Node,\r\n  EdgeProps,\r\n} from '@xyflow/react';\r\nimport { NodeInfo, EdgeData } from '../../types/flow';\r\n\r\n// é»˜è®¤èŠ‚ç‚¹å°ºå¯¸\r\nconst DEFAULT_WIDTH = 150;\r\nconst DEFAULT_HEIGHT = 50;\r\n\r\n// å­—ç¬¦ä¸²è½¬ Position\r\nfunction stringToPosition(str?: string): Position | undefined {\r\n  if (!str) return undefined;\r\n  const map: Record<string, Position> = {\r\n    top: Position.Top,\r\n    bottom: Position.Bottom,\r\n    left: Position.Left,\r\n    right: Position.Right,\r\n  };\r\n  return map[str.toLowerCase()];\r\n}\r\n\r\n// å®‰å…¨è·å–èŠ‚ç‚¹ä¿¡æ¯\r\nfunction getNodeInfo(node: any): NodeInfo {\r\n  const width = node?.measured?.width || node?.width || DEFAULT_WIDTH;\r\n  const height = node?.measured?.height || node?.height || DEFAULT_HEIGHT;\r\n  const x = node?.internals?.positionAbsolute?.x ?? node?.position?.x ?? 0;\r\n  const y = node?.internals?.positionAbsolute?.y ?? node?.position?.y ?? 0;\r\n\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y,\r\n    centerX: x + width / 2,\r\n    centerY: y + height / 2,\r\n  };\r\n}\r\n\r\n// è®¡ç®—æœ€ä½³è¿æ¥ä½ç½®ï¼ˆè‡ªåŠ¨æ¨¡å¼ï¼‰\r\nfunction getBestPosition(\r\n  sourceInfo: NodeInfo,\r\n  targetInfo: NodeInfo,\r\n): { sourcePos: Position; targetPos: Position } {\r\n  const dx = targetInfo.centerX - sourceInfo.centerX;\r\n  const dy = targetInfo.centerY - sourceInfo.centerY;\r\n  const absDx = Math.abs(dx);\r\n  const absDy = Math.abs(dy);\r\n\r\n  // ä¼˜å…ˆä½¿ç”¨å‚ç›´è¿æ¥ï¼ˆæµç¨‹å›¾é€šå¸¸æ˜¯ä»ä¸Šåˆ°ä¸‹ï¼‰\r\n  if (absDy > absDx * 0.3) {\r\n    if (dy > 0) {\r\n      return { sourcePos: Position.Bottom, targetPos: Position.Top };\r\n    } else {\r\n      return { sourcePos: Position.Top, targetPos: Position.Bottom };\r\n    }\r\n  } else {\r\n    if (dx > 0) {\r\n      return { sourcePos: Position.Right, targetPos: Position.Left };\r\n    } else {\r\n      return { sourcePos: Position.Left, targetPos: Position.Right };\r\n    }\r\n  }\r\n}\r\n\r\n// æ ¹æ®ä½ç½®è·å–åæ ‡\r\nfunction getCoords(info: NodeInfo, position: Position) {\r\n  switch (position) {\r\n    case Position.Top:\r\n      return { x: info.centerX, y: info.y };\r\n    case Position.Bottom:\r\n      return { x: info.centerX, y: info.y + info.height };\r\n    case Position.Left:\r\n      return { x: info.x, y: info.centerY };\r\n    case Position.Right:\r\n      return { x: info.x + info.width, y: info.centerY };\r\n  }\r\n}\r\n\r\n// ä½¿ç”¨è·¯å¾„ç‚¹ç”Ÿæˆè‡ªå®šä¹‰è·¯å¾„\r\nfunction buildPathWithWaypoints(\r\n  sourceX: number,\r\n  sourceY: number,\r\n  targetX: number,\r\n  targetY: number,\r\n  waypoints: Array<{ x: number; y: number }>,\r\n  edgeType: 'straight' | 'smoothstep' | 'step' = 'smoothstep',\r\n): string {\r\n  const points = [{ x: sourceX, y: sourceY }, ...waypoints, { x: targetX, y: targetY }];\r\n\r\n  if (edgeType === 'straight') {\r\n    return `M ${sourceX},${sourceY} L ${targetX},${targetY} `;\r\n  }\r\n\r\n  // æ„å»ºæŠ˜çº¿è·¯å¾„\r\n  let path = `M ${points[0].x},${points[0].y} `;\r\n  for (let i = 1; i < points.length; i++) {\r\n    if (edgeType === 'smoothstep' && i < points.length - 1) {\r\n      // å¹³æ»‘æŠ˜çº¿ï¼šåœ¨è½¬æŠ˜ç‚¹æ·»åŠ åœ†è§’\r\n      const prev = points[i - 1];\r\n      const curr = points[i];\r\n      const next = points[i + 1];\r\n      const radius = 8;\r\n\r\n      // è®¡ç®—åœ†è§’è·¯å¾„\r\n      if (prev.x === curr.x) {\r\n        // å‚ç›´è½¬æ°´å¹³\r\n        const dir = next.y > curr.y ? 1 : -1;\r\n        path += ` L ${curr.x},${curr.y - radius * dir} `;\r\n        path += ` Q ${curr.x},${curr.y} ${curr.x + radius * (next.x > curr.x ? 1 : -1)},${curr.y} `;\r\n      } else {\r\n        // æ°´å¹³è½¬å‚ç›´\r\n        const dir = next.x > curr.x ? 1 : -1;\r\n        path += ` L ${curr.x - radius * dir},${curr.y} `;\r\n        path += ` Q ${curr.x},${curr.y} ${curr.x},${curr.y + radius * (next.y > curr.y ? 1 : -1)} `;\r\n      }\r\n    } else {\r\n      path += ` L ${points[i].x},${points[i].y} `;\r\n    }\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\nexport function FloatingEdge({\r\n  id,\r\n  source,\r\n  target,\r\n  sourceHandleId,\r\n  targetHandleId,\r\n  markerEnd,\r\n  style,\r\n  label,\r\n  data,\r\n}: EdgeProps) {\r\n  const sourceNode = useInternalNode(source);\r\n  const targetNode = useInternalNode(target);\r\n\r\n  const edgeData = useMemo(() => {\r\n    if (!sourceNode || !targetNode) return null;\r\n\r\n    const sourceInfo = getNodeInfo(sourceNode);\r\n    const targetInfo = getNodeInfo(targetNode);\r\n\r\n    // æ”¯æŒæ‰‹åŠ¨æŒ‡å®š handle ä½ç½®ï¼Œå¦åˆ™è‡ªåŠ¨è®¡ç®—\r\n    const edgeData = (data || {}) as EdgeData;\r\n    const manualSourcePos = stringToPosition(sourceHandleId || edgeData.sourceHandle);\r\n    const manualTargetPos = stringToPosition(targetHandleId || edgeData.targetHandle);\r\n\r\n    let sourcePos: Position;\r\n    let targetPos: Position;\r\n\r\n    if (manualSourcePos && manualTargetPos) {\r\n      sourcePos = manualSourcePos;\r\n      targetPos = manualTargetPos;\r\n    } else {\r\n      const auto = getBestPosition(sourceInfo, targetInfo);\r\n      sourcePos = manualSourcePos || auto.sourcePos;\r\n      targetPos = manualTargetPos || auto.targetPos;\r\n    }\r\n\r\n    const sourceCoords = getCoords(sourceInfo, sourcePos);\r\n    const targetCoords = getCoords(targetInfo, targetPos);\r\n\r\n    // å¦‚æœæŒ‡å®šäº†è·¯å¾„ç‚¹ï¼Œä½¿ç”¨è‡ªå®šä¹‰è·¯å¾„\r\n    const waypoints = edgeData.waypoints;\r\n    const edgeType = edgeData.edgeType || 'smoothstep';\r\n\r\n    let path: string;\r\n    let labelX: number;\r\n    let labelY: number;\r\n\r\n    if (waypoints && waypoints.length > 0) {\r\n      // ä½¿ç”¨è·¯å¾„ç‚¹æ„å»ºè‡ªå®šä¹‰è·¯å¾„\r\n      path = buildPathWithWaypoints(\r\n        sourceCoords.x,\r\n        sourceCoords.y,\r\n        targetCoords.x,\r\n        targetCoords.y,\r\n        waypoints,\r\n        edgeType,\r\n      );\r\n      // æ ‡ç­¾ä½ç½®ï¼šå–ä¸­é—´è·¯å¾„ç‚¹çš„ä½ç½®\r\n      const midIndex = Math.floor(waypoints.length / 2);\r\n      const midPoint = waypoints[midIndex] || waypoints[0];\r\n      labelX = midPoint.x;\r\n      labelY = midPoint.y;\r\n    } else {\r\n      // ä½¿ç”¨è‡ªåŠ¨è®¡ç®—çš„è·¯å¾„\r\n      [path, labelX, labelY] = getSmoothStepPath({\r\n        sourceX: sourceCoords.x,\r\n        sourceY: sourceCoords.y,\r\n        sourcePosition: sourcePos,\r\n        targetX: targetCoords.x,\r\n        targetY: targetCoords.y,\r\n        targetPosition: targetPos,\r\n        borderRadius: 8,\r\n      });\r\n    }\r\n\r\n    return { path, labelX, labelY };\r\n  }, [sourceNode, targetNode, sourceHandleId, targetHandleId, data]);\r\n\r\n  if (!edgeData) return null;\r\n\r\n  return (\r\n    <>\r\n      <BaseEdge id={id} path={edgeData.path} markerEnd={markerEnd} style={style} />\r\n      {label && (\r\n        <EdgeLabelRenderer>\r\n          <div\r\n            style={{\r\n              position: 'absolute',\r\n              transform: `translate(-50 %, -50 %) translate(${edgeData.labelX}px, ${edgeData.labelY}px)`,\r\n              pointerEvents: 'all',\r\n              padding: '3px 8px',\r\n              borderRadius: 4,\r\n              backgroundColor: '#1e293b',\r\n              color: '#94a3b8',\r\n              fontSize: 12,\r\n              fontWeight: 500,\r\n            }}\r\n            className=\"nodrag nopan\"\r\n          >\r\n            {label}\r\n          </div>\r\n        </EdgeLabelRenderer>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\nexport default FloatingEdge;\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\FlowCanvas\\index.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Panel' is defined but never used.",
        "line": 7,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 8
      },
      {
        "ruleId": "react-hooks/set-state-in-effect",
        "severity": 2,
        "message": "Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nE:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\FlowCanvas\\index.tsx:191:7\n  189 |       (selectedElement && !newSelectedElement)\n  190 |     ) {\n> 191 |       setSelectedElement(newSelectedElement);\n      |       ^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  192 |     }\n  193 |   }, [nodes, edges, selectedElement]);\n  194 |",
        "line": 191,
        "column": 7,
        "nodeType": null,
        "endLine": 191,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 444,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 444,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": {
              "range": [
                14601,
                14604
              ],
              "text": "unknown"
            },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": {
              "range": [
                14601,
                14604
              ],
              "text": "never"
            },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 468,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 468,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": {
              "range": [
                15372,
                15375
              ],
              "text": "unknown"
            },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": {
              "range": [
                15372,
                15375
              ],
              "text": "never"
            },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 471,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 471,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": {
              "range": [
                15490,
                15493
              ],
              "text": "unknown"
            },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": {
              "range": [
                15490,
                15493
              ],
              "text": "never"
            },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useState, useEffect, useRef, memo } from 'react';\r\nimport {\r\n  ReactFlow,\r\n  ReactFlowProvider,\r\n  Controls,\r\n  Background,\r\n  Panel,\r\n  useNodesState,\r\n  useEdgesState,\r\n  useReactFlow,\r\n  Node,\r\n  Edge,\r\n  BackgroundVariant,\r\n  ConnectionMode,\r\n  MarkerType,\r\n  NodeChange,\r\n  EdgeChange,\r\n  SelectionMode,\r\n} from '@xyflow/react';\r\nimport '@xyflow/react/dist/style.css';\r\n\r\nimport { FlowNodeData, NodeUpdateParams, EdgeUpdateParams } from '../../types/flow';\r\nimport { CustomNode } from '../CustomNode';\r\nimport { GroupNode } from '../GroupNode';\r\nimport DraggableEdge from '../DraggableEdge';\r\nimport { NodeDetailPanel, SelectedElement } from '../NodeDetailPanel';\r\nimport { useFlowHistory } from '../../hooks/useFlowHistory';\r\nimport { useFlowClipboard } from '../../hooks/useFlowClipboard';\r\nimport { useAutoSave } from '../../hooks/useAutoSave';\r\nimport { useFlowHandlers } from '../../hooks/useFlowHandlers';\r\nimport { useFlowOperations } from '../../hooks/useFlowOperations';\r\nimport { useNodeAlignment } from '../../hooks/useNodeAlignment';\r\nimport { AlignmentToolbar } from './AlignmentToolbar';\r\nimport './styles.css';\r\n\r\n// è‡ªå®šä¹‰èŠ‚ç‚¹ç±»å‹\r\nconst nodeTypes = {\r\n  custom: CustomNode,\r\n  group: GroupNode,\r\n};\r\n\r\n// è‡ªå®šä¹‰è¾¹ç±»å‹\r\nconst edgeTypes = {\r\n  draggable: DraggableEdge,\r\n};\r\n\r\ninterface FlowCanvasProps {\r\n  nodes: Node<FlowNodeData>[];\r\n  edges: Edge[];\r\n  onNodesChange?: (changes: NodeChange[]) => void;\r\n  onEdgesChange?: (changes: EdgeChange[]) => void;\r\n  showSubflows?: boolean;\r\n  onToggleSubflows?: () => void;\r\n}\r\n\r\nimport { OffscreenIndicators } from './OffscreenIndicators';\r\n\r\n// å†…éƒ¨ç»„ä»¶ï¼šä½¿ç”¨ useReactFlow hook (ä½¿ç”¨ memo ä¼˜åŒ–æ€§èƒ½)\r\nconst FlowCanvasContent = memo(function FlowCanvasContent({\r\n  initialNodes,\r\n  initialEdges,\r\n  // These props are received but not currently used - prefixed with _ to satisfy ESLint\r\n  showSubflows: _showSubflows,\r\n  onToggleSubflows: _onToggleSubflows,\r\n}: {\r\n  initialNodes: Node<FlowNodeData>[];\r\n  initialEdges: Edge[];\r\n  showSubflows?: boolean;\r\n  onToggleSubflows?: () => void;\r\n}) {\r\n  // è¿ç§»æ—§çš„ edge handle ID\r\n  const migratedEdges = initialEdges.map((edge) => {\r\n    let sourceHandle = edge.sourceHandle;\r\n    let targetHandle = edge.targetHandle;\r\n\r\n    // å°†æ—§çš„ \"top\" handle ID è½¬æ¢ä¸ºæ­£ç¡®çš„ ID\r\n    if (sourceHandle === 'top') {\r\n      sourceHandle = 'top-source'; // \"top\" ä½œä¸º source åº”è¯¥ä½¿ç”¨ \"top-source\"\r\n    }\r\n    if (targetHandle === 'top') {\r\n      targetHandle = 'top-target'; // \"top\" ä½œä¸º target åº”è¯¥ä½¿ç”¨ \"top-target\"\r\n    }\r\n\r\n    // æ‰¹é‡æ›´æ–°ï¼šç»Ÿä¸€è¿çº¿æ ‡ç­¾æ ·å¼\r\n    const labelBgStyle = edge.labelBgStyle || { fill: '#ffffff' };\r\n    const newLabelBgStyle = {\r\n      ...labelBgStyle,\r\n      fillOpacity: 0.8,\r\n    };\r\n\r\n    // ç¡®ä¿ data ä¸­ä¹Ÿæœ‰å¯¹åº”çš„å€¼\r\n    const data = edge.data || {};\r\n    const newData = {\r\n      ...data,\r\n    };\r\n\r\n    return {\r\n      ...edge,\r\n      sourceHandle,\r\n      targetHandle,\r\n      labelBgStyle: newLabelBgStyle,\r\n      data: newData,\r\n    } as Edge;\r\n  });\r\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\r\n  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>(migratedEdges);\r\n  // Use shared type\r\n  const [selectedElement, setSelectedElement] = useState<SelectedElement | null>(null);\r\n  const [showPanel, setShowPanel] = useState(false);\r\n  const { fitView, screenToFlowPosition, getNodes } = useReactFlow<Node<FlowNodeData>, Edge>();\r\n\r\n  // ä½¿ç”¨è‡ªå®šä¹‰ Hooks\r\n  const {\r\n    initHistory,\r\n    saveHistory,\r\n    undo: historyUndo,\r\n    redo: historyRedo,\r\n    isUndoRedoRef,\r\n  } = useFlowHistory();\r\n\r\n  // ç”¨äºèŠ‚ç‚¹æ‹–åŠ¨é˜²æŠ–ä¿å­˜å†å²çš„ ref\r\n  const dragHistoryTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const isDraggingRef = useRef(false);\r\n\r\n  const { copyNodes: clipboardCopyNodes, pasteNodes: clipboardPasteNodes } = useFlowClipboard();\r\n\r\n  // ä½¿ç”¨è‡ªåŠ¨ä¿å­˜ Hook\r\n  const { triggerAutoSave, getFlowData } = useAutoSave(nodes, edges, () => isUndoRedoRef.current);\r\n\r\n  // ä½¿ç”¨èŠ‚ç‚¹å¯¹é½ Hook\r\n  const { alignNodes } = useNodeAlignment({ setNodes, saveHistory });\r\n\r\n  // å½“åˆå§‹æ•°æ®å˜åŒ–æ—¶æ›´æ–°èŠ‚ç‚¹å’Œè¾¹\r\n  useEffect(() => {\r\n    // åªæœ‰å½“ä¼ å…¥æœ‰æ•ˆçš„åˆå§‹æ•°æ®ä¸”å½“å‰ store ä¸ºç©ºæ—¶æ‰åˆå§‹åŒ–\r\n    if (initialNodes.length > 0 && nodes.length === 0) {\r\n      setNodes(initialNodes);\r\n      setEdges(initialEdges);\r\n    }\r\n  }, [initialNodes, initialEdges, setNodes, setEdges, nodes.length]);\r\n\r\n  useEffect(() => {\r\n    if (nodes.length > 0 || edges.length > 0) {\r\n      initHistory(nodes, edges);\r\n    }\r\n  }, [nodes, edges, initHistory]);\r\n\r\n  // Sync selectedElement when nodes or edges change (e.g. resize or data update from other sources)\r\n  // ä½¿ç”¨ setTimeout å»¶è¿Ÿ setStateï¼Œé¿å…åŒæ­¥è°ƒç”¨å¯¼è‡´çš„çº§è”æ¸²æŸ“è­¦å‘Š\r\n  useEffect(() => {\r\n    if (!selectedElement) return;\r\n\r\n    // æ¯”è¾ƒå½“å‰é€‰ä¸­çš„å…ƒç´ ä¸ store ä¸­çš„é€‰ä¸­çŠ¶æ€\r\n    const selectedNode = nodes.find((n) => n.selected);\r\n    const selectedEdge = edges.find((e) => e.selected);\r\n\r\n    let newSelectedElement: SelectedElement | null = null;\r\n    if (selectedNode) {\r\n      newSelectedElement = {\r\n        type: 'node',\r\n        data: selectedNode.data,\r\n        node: selectedNode,\r\n      };\r\n    } else if (selectedEdge) {\r\n      newSelectedElement = {\r\n        type: 'edge',\r\n        data: selectedEdge,\r\n      };\r\n    }\r\n\r\n    // åªæœ‰å½“é€‰ä¸­çš„å…ƒç´ çœŸæ­£å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°çŠ¶æ€\r\n    // å¦‚æœä¹‹å‰æ²¡æœ‰é€‰ä¸­ä¸”ç°åœ¨ä¹Ÿæ²¡æœ‰é€‰ä¸­ï¼Œä¸æ›´æ–°\r\n    if (!selectedElement && !newSelectedElement) {\r\n      return;\r\n    }\r\n\r\n    // å¦‚æœç±»å‹ä¸åŒï¼Œæˆ–è€… ID ä¸åŒï¼Œåˆ™æ›´æ–°\r\n    const currentId = selectedElement?.type === 'node' ? selectedElement.node?.id : selectedElement?.data.id;\r\n    const newId = newSelectedElement?.type === 'node' ? newSelectedElement.node?.id : newSelectedElement?.data.id;\r\n\r\n    const isDifferentId = currentId !== newId;\r\n\r\n    // æ·±åº¦æ¯”è¾ƒ data æ˜¯å¦å˜åŒ–ï¼ˆå¯é€‰ï¼Œä½†é€šå¸¸ ID å˜åŒ–å°±è¶³å¤Ÿäº†ï¼‰\r\n    // è¿™é‡Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ ID å’Œç±»å‹çš„å˜åŒ–\r\n    if (\r\n      isDifferentId ||\r\n      selectedElement?.type !== newSelectedElement?.type ||\r\n      (!selectedElement && newSelectedElement) ||\r\n      (selectedElement && !newSelectedElement)\r\n    ) {\r\n      setSelectedElement(newSelectedElement);\r\n    }\r\n  }, [nodes, edges, selectedElement]);\r\n\r\n  // ç›‘å¬é€‰ä¸­èŠ‚ç‚¹å˜åŒ–ï¼Œé«˜äº®å…³è”èŠ‚ç‚¹ï¼ˆæ­£å‘ï¼‰å’Œå¼•ç”¨æºèŠ‚ç‚¹ï¼ˆåå‘ï¼‰\r\n  useEffect(() => {\r\n    // è¾…åŠ©å‡½æ•°ï¼šæ¸…ç†é«˜äº®ç±»å\r\n    const removeHighlight = (cls: string = '') =>\r\n      cls.replace('related-node-highlight', '').replace('source-node-highlight', '').trim();\r\n    const removeEdgeHighlight = (cls: string = '') =>\r\n      cls.replace('related-edge-highlight', '').replace('source-edge-highlight', '').trim();\r\n\r\n    if (selectedElement?.type === 'node') {\r\n      const selectedId = selectedElement.data.id;\r\n      // 1. æ­£å‘å…³è”\r\n      const relatedIds = selectedElement.data.relatedNodeIds || [];\r\n\r\n      // 2. åå‘å…³è”ï¼šä½¿ç”¨ getNodes() è·å–æœ€æ–°èŠ‚ç‚¹åˆ—è¡¨ï¼Œé¿å…ä¾èµ– nodes å¯¼è‡´å¾ªç¯å¼•ç”¨\r\n      const currentNodes = getNodes();\r\n      const sourceIds = currentNodes\r\n        .filter(n => n.data.relatedNodeIds?.includes(selectedId))\r\n        .map(n => n.id);\r\n\r\n      const hasRelated = relatedIds.length > 0;\r\n      const hasSource = sourceIds.length > 0;\r\n\r\n      if (hasRelated || hasSource) {\r\n        // Highlight Nodes\r\n        setNodes((nds) => {\r\n          let hasChanges = false;\r\n          const newNodes = nds.map(node => {\r\n            const isRelated = relatedIds.includes(node.id);\r\n            const isSource = sourceIds.includes(node.id);\r\n            const originalClass = node.className || '';\r\n\r\n            // Remove old highlights first to compare cleanly\r\n            let newClass = removeHighlight(originalClass);\r\n\r\n            if (isRelated) {\r\n              newClass = `${newClass} related-node-highlight`;\r\n            }\r\n            if (isSource) {\r\n              newClass = `${newClass} source-node-highlight`;\r\n            }\r\n            newClass = newClass.trim();\r\n\r\n            if (newClass !== originalClass) {\r\n              hasChanges = true;\r\n              return { ...node, className: newClass };\r\n            }\r\n            return node;\r\n          });\r\n          return hasChanges ? newNodes : nds;\r\n        });\r\n\r\n        // Highlight Edges\r\n        setEdges((eds) => {\r\n          let hasChanges = false;\r\n          const newEdges = eds.map(edge => {\r\n            const isConnectedToRelated = (edge.source === selectedId && relatedIds.includes(edge.target)) ||\r\n              (edge.target === selectedId && relatedIds.includes(edge.source));\r\n\r\n            const isConnectedToSource = (edge.source === selectedId && sourceIds.includes(edge.target)) ||\r\n              (edge.target === selectedId && sourceIds.includes(edge.source));\r\n\r\n            const originalClass = edge.className || '';\r\n            let newClass = removeEdgeHighlight(originalClass);\r\n            let newAnimated = edge.animated;\r\n\r\n            // Restore animated default if it was modified (we assume default is true or false? \r\n            // Actually existing logic assumed we set it to true if highlighted.\r\n            // Let's preserve original animation state if not highlighted? \r\n            // Standard DraggableEdge isn't animated by default in some configs, but user asked to restore \"flowing\". \r\n            // Let's set animated=true if highlighted or restoring.\r\n\r\n            if (isConnectedToRelated) {\r\n              newClass = `${newClass} related-edge-highlight`;\r\n              newAnimated = true;\r\n            } else if (isConnectedToSource) {\r\n              newClass = `${newClass} source-edge-highlight`;\r\n              newAnimated = true;\r\n            } else if ((edge.className || '').includes('related-edge-highlight') || (edge.className || '').includes('source-edge-highlight')) {\r\n              // Was highlighted, now removing. Restore animation to true per user request\r\n              newAnimated = true;\r\n            }\r\n\r\n            newClass = newClass.trim();\r\n\r\n            if (newClass !== originalClass || newAnimated !== edge.animated) {\r\n              hasChanges = true;\r\n              return { ...edge, className: newClass, animated: newAnimated };\r\n            }\r\n            return edge;\r\n          });\r\n          return hasChanges ? newEdges : eds;\r\n        });\r\n      } else {\r\n        // Clear if no relations found\r\n        setNodes((nds) => {\r\n          let hasChanges = false;\r\n          const newNodes = nds.map(node => {\r\n            // Only update if it HAS the class\r\n            if (node.className?.includes('related-node-highlight') || node.className?.includes('source-node-highlight')) {\r\n              hasChanges = true;\r\n              return { ...node, className: removeHighlight(node.className) };\r\n            }\r\n            return node;\r\n          });\r\n          return hasChanges ? newNodes : nds;\r\n        });\r\n\r\n        setEdges((eds) => {\r\n          let hasChanges = false;\r\n          const newEdges = eds.map(edge => {\r\n            if (edge.className?.includes('related-edge-highlight') || edge.className?.includes('source-edge-highlight')) {\r\n              hasChanges = true;\r\n              return { ...edge, className: removeEdgeHighlight(edge.className), animated: true };\r\n            }\r\n            return edge;\r\n          });\r\n          return hasChanges ? newEdges : eds;\r\n        });\r\n      }\r\n\r\n    } else {\r\n      // æ²¡æœ‰ä»»ä½•é€‰ä¸­èŠ‚ç‚¹ï¼Œæ¸…é™¤æ‰€æœ‰é«˜äº®\r\n      setNodes((nds) => {\r\n        let hasChanges = false;\r\n        const newNodes = nds.map(node => {\r\n          if (node.className?.includes('related-node-highlight') || node.className?.includes('source-node-highlight')) {\r\n            hasChanges = true;\r\n            return { ...node, className: removeHighlight(node.className) };\r\n          }\r\n          return node;\r\n        });\r\n        return hasChanges ? newNodes : nds;\r\n      });\r\n\r\n      setEdges((eds) => {\r\n        let hasChanges = false;\r\n        const newEdges = eds.map(edge => {\r\n          if (edge.className?.includes('related-edge-highlight') || edge.className?.includes('source-edge-highlight')) {\r\n            hasChanges = true;\r\n            return { ...edge, className: removeEdgeHighlight(edge.className), animated: true };\r\n          }\r\n          return edge;\r\n        });\r\n        return hasChanges ? newEdges : eds;\r\n      });\r\n    }\r\n  }, [selectedElement, setNodes, setEdges, getNodes]); // Removed 'nodes' dependency\r\n\r\n  // åŒ…è£… undo/redo å‡½æ•°ä»¥å…³é—­è¯¦æƒ…é¢æ¿\r\n  const undo = useCallback(() => {\r\n    historyUndo(setNodes, setEdges);\r\n    setSelectedElement(null);\r\n    setShowPanel(false);\r\n  }, [historyUndo, setNodes, setEdges]);\r\n\r\n  const redo = useCallback(() => {\r\n    historyRedo(setNodes, setEdges);\r\n    setSelectedElement(null);\r\n    setShowPanel(false);\r\n  }, [historyRedo, setNodes, setEdges]);\r\n\r\n  // åŒ…è£… copyNodes ä»¥è·å–é€‰ä¸­çš„èŠ‚ç‚¹\r\n  const copyNodes = useCallback(() => {\r\n    const selectedNodes = getNodes().filter((node) => node.selected);\r\n    clipboardCopyNodes(selectedNodes);\r\n  }, [getNodes, clipboardCopyNodes]);\r\n\r\n  // åŒ…è£… pasteNodes ä»¥ä¼ å…¥éœ€è¦çš„å‚æ•°\r\n  const pasteNodes = useCallback(() => {\r\n    clipboardPasteNodes(setNodes, edges, () => {\r\n      saveHistory(nodes, edges);\r\n    });\r\n    // è§¦å‘è‡ªåŠ¨ä¿å­˜\r\n    setTimeout(() => {\r\n      triggerAutoSave();\r\n    }, 0);\r\n  }, [clipboardPasteNodes, setNodes, edges, saveHistory, nodes, triggerAutoSave]);\r\n\r\n  // ä½¿ç”¨ useFlowHandlers Hook\r\n  const {\r\n    wrappedOnNodesChange,\r\n    wrappedOnEdgesChange,\r\n    onNodeClick,\r\n    onEdgeClick,\r\n    closePanel,\r\n    onPaneClick,\r\n    isValidConnection,\r\n    onConnect,\r\n    onNodeUpdate,\r\n    onEdgeUpdate,\r\n    onEdgeDoubleClick,\r\n  } = useFlowHandlers({\r\n    nodes,\r\n    edges,\r\n    setNodes,\r\n    setEdges,\r\n    onNodesChange,\r\n    onEdgesChange,\r\n    selectedElement,\r\n    setSelectedElement,\r\n    showPanel,\r\n    setShowPanel,\r\n    saveHistory,\r\n    triggerAutoSave,\r\n    isUndoRedoRef,\r\n    isDraggingRef,\r\n    dragHistoryTimerRef,\r\n  });\r\n\r\n  // ä½¿ç”¨ useFlowOperations Hook\r\n  const {\r\n    onAddNode,\r\n    onSave,\r\n    onExport,\r\n    onImport,\r\n    onCreateGroup,\r\n    onUngroup,\r\n    onRemoveFromGroup,\r\n    onUpdateGroupLabel,\r\n  } = useFlowOperations({\r\n    nodes,\r\n    edges,\r\n    setNodes,\r\n    setEdges,\r\n    screenToFlowPosition,\r\n    saveHistory,\r\n    triggerAutoSave,\r\n    getFlowData,\r\n    fitView,\r\n  });\r\n\r\n  // ç›‘å¬åˆ†ç»„æ ‡ç­¾æ›´æ”¹äº‹ä»¶\r\n  useEffect(() => {\r\n    const handleGroupLabelChange = (e: CustomEvent<{ id: string; label: string }>) => {\r\n      onUpdateGroupLabel(e.detail.id, e.detail.label);\r\n    };\r\n\r\n    window.addEventListener('groupLabelChange', handleGroupLabelChange as EventListener);\r\n    return () => {\r\n      window.removeEventListener('groupLabelChange', handleGroupLabelChange as EventListener);\r\n    };\r\n  }, [onUpdateGroupLabel]);\r\n\r\n\r\n\r\n  // é€‚é… NodeDetailPanel çš„æ›´æ–°å›è°ƒ\r\n  const handleNodeDetailChange: (id: string, updates: NodeUpdateParams) => void = useCallback(\r\n    (id: string, updates: NodeUpdateParams) => {\r\n      // Direct pass-through of ID and updates to onNodeUpdate which now handles merging atomically\r\n      onNodeUpdate(id, (updates.data || {}) as any, updates.style);\r\n    },\r\n    [onNodeUpdate]\r\n  );\r\n\r\n  const handleEdgeDetailChange: (id: string, updates: EdgeUpdateParams) => void = useCallback(\r\n    (id: string, updates: EdgeUpdateParams) => {\r\n      const edge = edges.find((e) => e.id === id);\r\n      if (!edge) return;\r\n\r\n      const newEdge = { ...edge, ...updates } as Edge;\r\n      onEdgeUpdate(newEdge);\r\n    },\r\n    [edges, onEdgeUpdate]\r\n  );\r\n\r\n  // åˆ†ç»„å±æ€§æ›´æ–°å›è°ƒ\r\n  const handleGroupChange = useCallback(\r\n    (id: string, updates: { label?: string; color?: string }) => {\r\n      setNodes((nds) =>\r\n        nds.map((node) => {\r\n          if (node.id === id && node.type === 'group') {\r\n            const newData = { ...node.data };\r\n            if (updates.label !== undefined) {\r\n              (newData as any).label = updates.label;\r\n            }\r\n            if (updates.color !== undefined) {\r\n              (newData as any).color = updates.color;\r\n            }\r\n            return { ...node, data: newData };\r\n          }\r\n          return node;\r\n        })\r\n      );\r\n      triggerAutoSave();\r\n    },\r\n    [setNodes, triggerAutoSave]\r\n  );\r\n\r\n  // è§£æ•£åˆ†ç»„æ—¶å…³é—­é¢æ¿\r\n  const handleUngroup = useCallback(\r\n    (groupId: string) => {\r\n      onUngroup(groupId);\r\n      setSelectedElement(null);\r\n      setShowPanel(false);\r\n    },\r\n    [onUngroup, setSelectedElement, setShowPanel]\r\n  );\r\n\r\n  // ä»åˆ†ç»„ç§»é™¤èŠ‚ç‚¹æ—¶æ›´æ–°é¢æ¿\r\n  const handleRemoveFromGroup = useCallback(\r\n    (nodeId: string) => {\r\n      onRemoveFromGroup(nodeId);\r\n    },\r\n    [onRemoveFromGroup]\r\n  );\r\n\r\n  // é”®ç›˜å¿«æ·é”®æ”¯æŒ\r\n  useEffect(() => {\r\n    const handleKeyDown = (e: KeyboardEvent) => {\r\n      // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†æˆ–æ–‡æœ¬åŸŸä¸­ï¼Œä¸æ‹¦æˆªå¿«æ·é”®ï¼Œè®©æµè§ˆå™¨åŸç”ŸåŠŸèƒ½ç”Ÿæ•ˆ\r\n      const target = e.target as HTMLElement;\r\n      const isInputElement =\r\n        target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\r\n\r\n      if (isInputElement) {\r\n        // åœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¸æ‹¦æˆªï¼Œè®©æµè§ˆå™¨åŸç”ŸåŠŸèƒ½å·¥ä½œ\r\n        return;\r\n      }\r\n\r\n      // Ctrl+C æˆ– Cmd+C (Mac) - å¤åˆ¶\r\n      if ((e.ctrlKey || e.metaKey) && e.key === 'c') {\r\n        e.preventDefault();\r\n        copyNodes();\r\n        return;\r\n      }\r\n\r\n      // Ctrl+V æˆ– Cmd+V (Mac) - ç²˜è´´\r\n      if ((e.ctrlKey || e.metaKey) && e.key === 'v') {\r\n        e.preventDefault();\r\n        pasteNodes();\r\n        return;\r\n      }\r\n\r\n      // Ctrl+Z æˆ– Cmd+Z (Mac) - æ’¤é”€\r\n      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\r\n        e.preventDefault();\r\n        undo();\r\n        return;\r\n      }\r\n\r\n      // Ctrl+Y æˆ– Ctrl+Shift+Z æˆ– Cmd+Shift+Z (Mac) - é‡åš\r\n      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\r\n        e.preventDefault();\r\n        redo();\r\n        return;\r\n      }\r\n\r\n      // Ctrl+G æˆ– Cmd+G (Mac) - åˆ›å»ºåˆ†ç»„\r\n      if ((e.ctrlKey || e.metaKey) && e.key === 'g' && !e.shiftKey) {\r\n        e.preventDefault();\r\n        onCreateGroup();\r\n        return;\r\n      }\r\n\r\n      // Ctrl+Shift+G æˆ– Cmd+Shift+G (Mac) - è§£æ•£åˆ†ç»„\r\n      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'G') {\r\n        e.preventDefault();\r\n        // å¦‚æœé€‰ä¸­çš„æ˜¯åˆ†ç»„èŠ‚ç‚¹ï¼Œåˆ™è§£æ•£è¯¥åˆ†ç»„\r\n        if (selectedElement?.type === 'node' && selectedElement.node?.type === 'group') {\r\n          // ä½¿ç”¨ handleUngroup ç¡®ä¿é¢æ¿å…³é—­\r\n          handleUngroup(selectedElement.data.id as string);\r\n        }\r\n        return;\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    return () => window.removeEventListener('keydown', handleKeyDown);\r\n  }, [undo, redo, copyNodes, pasteNodes, onCreateGroup, handleUngroup, selectedElement]); // Added handleUngroup dependency\r\n\r\n  // Determine alignment toolbar visibility (when more than 1 node is selected)\r\n  const showAlignmentToolbar = nodes.filter((n) => n.selected).length > 1;\r\n\r\n  return (\r\n    <div className=\"flow-canvas-container\">\r\n      {/* Top Toolbar Area - Outside of ReactFlow to prevent overlap */}\r\n      <div className=\"flow-controls-toolbar\">\r\n        <div className=\"flow-controls\">\r\n          <button\r\n            className=\"control-btn btn-save\"\r\n            onClick={onSave}\r\n            title=\"ä¿å­˜åˆ°æœ¬åœ°ç‰ˆæœ¬åº“ (Ctrl+S)\"\r\n          >\r\n            ğŸ’¾ ä¿å­˜\r\n          </button>\r\n          <button\r\n            className=\"control-btn btn-export\"\r\n            onClick={onExport}\r\n            title=\"å¯¼å‡º JSON æ–‡ä»¶\"\r\n          >\r\n            ğŸ“¤ å¯¼å‡º\r\n          </button>\r\n          <button\r\n            className=\"control-btn btn-import\"\r\n            onClick={onImport}\r\n            title=\"å¯¼å…¥ JSON æ–‡ä»¶\"\r\n          >\r\n            ğŸ“¥ å¯¼å…¥\r\n          </button>\r\n          <div\r\n            className=\"divider\"\r\n            style={{ width: 1, height: 20, background: '#e2e8f0', margin: '0 8px' }}\r\n          ></div>\r\n          <button className=\"control-btn\" onClick={undo} title=\"æ’¤é”€ (Ctrl+Z)\">\r\n            â†¶ æ’¤é”€\r\n          </button>\r\n          <button className=\"control-btn\" onClick={redo} title=\"é‡åš (Ctrl+Y)\">\r\n            â†· é‡åš\r\n          </button>\r\n          <div\r\n            className=\"divider\"\r\n            style={{ width: 1, height: 20, background: '#e2e8f0', margin: '0 8px' }}\r\n          ></div>\r\n          <button\r\n            className=\"control-btn btn-node\"\r\n            onClick={() => onAddNode('process')}\r\n            title=\"æ·»åŠ æµç¨‹èŠ‚ç‚¹\"\r\n          >\r\n            â• æµç¨‹èŠ‚ç‚¹\r\n          </button>\r\n          <button\r\n            className=\"control-btn btn-node\"\r\n            onClick={() => onAddNode('decision')}\r\n            title=\"æ·»åŠ åˆ¤æ–­èŠ‚ç‚¹\"\r\n          >\r\n            â• åˆ¤æ–­èŠ‚ç‚¹\r\n          </button>\r\n          <button className=\"control-btn btn-node\" onClick={() => onAddNode('data')} title=\"æ·»åŠ æ•°æ®èŠ‚ç‚¹\">\r\n            â• æ•°æ®èŠ‚ç‚¹\r\n          </button>\r\n          <button\r\n            className=\"control-btn btn-node\"\r\n            onClick={() => onAddNode('terminator')}\r\n            title=\"æ·»åŠ å¼€å§‹èŠ‚ç‚¹\"\r\n          >\r\n            â• å¼€å§‹èŠ‚ç‚¹\r\n          </button>\r\n          <div\r\n            className=\"divider\"\r\n            style={{ width: 1, height: 20, background: '#e2e8f0', margin: '0 8px' }}\r\n          ></div>\r\n          <button\r\n            className=\"control-btn btn-group\"\r\n            onClick={onCreateGroup}\r\n            title=\"å°†é€‰ä¸­èŠ‚ç‚¹åˆ›å»ºä¸ºåˆ†ç»„ (Ctrl+G)\"\r\n          >\r\n            ğŸ“ åˆ›å»ºåˆ†ç»„\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Main Canvas Area */}\r\n      <div className=\"canvas-area\">\r\n        <AlignmentToolbar\r\n          visible={showAlignmentToolbar}\r\n          onAlign={alignNodes}\r\n        />\r\n        <ReactFlow\r\n          nodes={nodes}\r\n          edges={edges}\r\n          onNodesChange={wrappedOnNodesChange}\r\n          onEdgesChange={wrappedOnEdgesChange}\r\n          onConnect={onConnect}\r\n          isValidConnection={isValidConnection}\r\n          connectionMode={ConnectionMode.Loose}\r\n          onNodeClick={onNodeClick}\r\n          onEdgeClick={onEdgeClick}\r\n          onEdgeDoubleClick={onEdgeDoubleClick}\r\n          onPaneClick={onPaneClick}\r\n          nodeTypes={nodeTypes}\r\n          edgeTypes={edgeTypes}\r\n          fitView\r\n          fitViewOptions={{ padding: 0.3, maxZoom: 1.2 }}\r\n          minZoom={0.5}\r\n          maxZoom={2}\r\n          defaultEdgeOptions={{\r\n            type: 'draggable', // é»˜è®¤ä½¿ç”¨å¯æ‹–æ‹½ Edge\r\n            animated: true,\r\n            style: { stroke: '#64748b', strokeWidth: 1 },\r\n            // é»˜è®¤ç®­å¤´æŒ‡å‘ç›®æ ‡èŠ‚ç‚¹ï¼ˆtargetï¼‰\r\n            markerEnd: {\r\n              type: MarkerType.ArrowClosed,\r\n              color: '#64748b',\r\n              width: 16,\r\n              height: 16,\r\n            },\r\n            // ç¡®ä¿ä¸è®¾ç½® markerStartï¼Œé¿å…ç®­å¤´æŒ‡å‘é”™è¯¯çš„æ–¹å‘\r\n            markerStart: undefined,\r\n          }}\r\n          nodesDraggable={true}\r\n          nodesConnectable={true} // å¼€å¯è¿çº¿\r\n          elementsSelectable={true}\r\n          selectionOnDrag={false}\r\n          selectionMode={SelectionMode.Partial}\r\n          selectionKeyCode=\"Shift\" // æŒ‰ä½ Shift + å·¦é”®æ¡†é€‰\r\n          panOnDrag={true} // å·¦é”®æ‹–æ‹½å¹³ç§»ç”»å¸ƒ\r\n          style={{ width: '100%', height: '100%' }}\r\n        >\r\n          <Background\r\n            variant={BackgroundVariant.Dots}\r\n            gap={24}\r\n            size={1.5}\r\n            color=\"#475569\"\r\n            style={{ opacity: 0.4 }}\r\n          />\r\n\r\n          <Controls />\r\n          {/* Controls used to be here, now moved out */}\r\n        </ReactFlow>\r\n\r\n        {/* æŒ‡ç¤ºå™¨å±‚ - ç§»åˆ° ReactFlow å¤–éƒ¨ä»¥é¿å…éšç”»å¸ƒç¼©æ”¾å¹³ç§» */}\r\n        <OffscreenIndicators\r\n          nodes={nodes}\r\n          edges={edges}\r\n          selectedNodeId={selectedElement?.type === 'node' ? selectedElement.data.id : null}\r\n        />\r\n\r\n        {/* èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ */}\r\n        <NodeDetailPanel\r\n          selectedElement={selectedElement}\r\n          visible={showPanel}\r\n          onClose={closePanel}\r\n          onNodeChange={handleNodeDetailChange}\r\n          onEdgeChange={handleEdgeDetailChange}\r\n          onGroupChange={handleGroupChange}\r\n          onUngroup={handleUngroup}\r\n          onRemoveFromGroup={handleRemoveFromGroup}\r\n          allNodes={nodes}\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\n// å¤–éƒ¨ç»„ä»¶ï¼šæä¾› ReactFlowProvider\r\nexport function FlowCanvas({ nodes: initialNodes, edges: initialEdges }: FlowCanvasProps) {\r\n  return (\r\n    <ReactFlowProvider>\r\n      <FlowCanvasContent initialNodes={initialNodes} initialEdges={initialEdges} />\r\n    </ReactFlowProvider>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\ä¸šåŠ¡å…¨æ™¯å›¾_google\\src\\components\\NodeDetailPanel\\EdgePropertiesPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]